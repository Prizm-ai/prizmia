import logging
import os
from datetime import datetime
from typing import Dict, List, Optional

from .agent_veille import AgentVeille
from .agent_redacteur import AgentRedacteur
from .agent_redacteur_chef import AgentRedacteurChef
from .agent_mailchimp import AgentMailchimp
from .agent_template import AgentTemplate

class Orchestrator:
    def __init__(self):
        """Initialise l'orchestrateur avec tous les agents"""
        # Chargement des variables d'environnement
        from dotenv import load_dotenv
        load_dotenv()
        
        # R√©cup√©ration des cl√©s API
        openai_api_key = os.getenv('OPENAI_API_KEY')
        mailchimp_api_key = os.getenv('MAILCHIMP_API_KEY')
        mailchimp_list_id = os.getenv('MAILCHIMP_LIST_ID')
        
        # Instanciation des agents
        self.agent_veille = AgentVeille()
        self.agent_redacteur = AgentRedacteur(openai_api_key=openai_api_key)
        self.agent_redacteur_chef = AgentRedacteurChef()
        self.agent_mailchimp = AgentMailchimp(api_key=mailchimp_api_key, list_id=mailchimp_list_id)
        self.agent_template = AgentTemplate()
        
        self.test_mode = os.getenv('TEST_MODE', 'True').lower() == 'true'

        # Configuration du logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
    
    def generer_newsletter_complete(self, limit_articles: int = 10) -> Dict:
        """G√©n√®re une newsletter compl√®te avec le workflow multi-agents"""
        try:
            logging.info("üéº D√©marrage du workflow de g√©n√©ration de newsletter")
            
            # 1. Collecte des articles
            logging.info("1Ô∏è‚É£ Collecte des articles IA...")
            articles = self.agent_veille.collecter_articles(limit=limit_articles)

            if not articles:
                raise Exception("Aucun article collect√©")
            
            logging.info(f"‚úÖ {len(articles)} articles collect√©s")
            
            # 2. Analyse des tendances
            logging.info("2Ô∏è‚É£ Analyse des tendances...")
            tendances = self.agent_veille.analyser_tendances(articles)
            
            # 3. R√©daction du contenu
            logging.info("3Ô∏è‚É£ R√©daction du contenu...")
            contenu_brut = self.agent_redacteur.rediger_contenu(articles, tendances)
            
            if not contenu_brut:
                raise Exception("√âchec de la r√©daction du contenu")
            
            # 4. √âdition et finalisation
            logging.info("4Ô∏è‚É£ √âdition et finalisation...")
            contenu_final = self.agent_redacteur_chef.finaliser_newsletter(contenu_brut)
            
            if not contenu_final:
                raise Exception("√âchec de la finalisation de la newsletter")
            
            print("‚úÖ Newsletter finalis√©e avec succ√®s")
            
            # 5. Application du template HTML
            logging.info("5Ô∏è‚É£ Application du template HTML...")
            contenu_html = self.agent_template.generer_html(contenu_final)
            
            if not contenu_html:
                raise Exception("√âchec de la g√©n√©ration du template HTML")
            
            # 6. Diffusion via Mailchimp
            print("INFO: 6Ô∏è‚É£ Diffusion via Mailchimp...")
            
            # Pr√©paration des donn√©es pour Mailchimp
            titre_final = f"Newsletter IA - {datetime.now().strftime('%d/%m/%Y')}"
            html_content = str(contenu_html) if contenu_html else ""
            
            # Debug
            print(f"INFO: üîç Debug: contenu_html type = {type(contenu_html)}")
            
            # Appel Mailchimp
            diffusion = self.agent_mailchimp.envoyer_newsletter(
                contenu_html=html_content,
                titre=titre_final
            )
            
            print(f"INFO: üîç Debug: diffusion type = {type(diffusion)}")
            print(f"üîç Debug: contenu de diffusion = {diffusion}")
            
            # Traitement du r√©sultat
            if isinstance(diffusion, dict):
                success = diffusion.get('statut') in ['test_success', 'success']
                message = diffusion.get('message', 'Aucun message')
                print(f"üîç Debug: success = {success}")
                print(f"üîç Debug: message = {message}")
            else:
                success = False
                message = "Format de r√©ponse inattendu"
            
            print("üîç Debug: Fin du traitement - tout OK")
            
            # Collecter les articles depuis le processus de veille
            articles_collectes = articles if 'articles' in locals() else []
            
            # Collecter les statistiques depuis la diffusion
            statistiques = {}
            if isinstance(diffusion, dict) and 'statistiques' in diffusion:
                statistiques = diffusion['statistiques']
            elif isinstance(diffusion, dict):
                statistiques = {
                    'diffusion_success': diffusion.get('success', False),
                    'message': diffusion.get('message', ''),
                    'timestamp': datetime.now().isoformat()
                }
            
            # Retour du r√©sultat final - AVEC TOUTES LES CL√âS REQUISES
            return {
                'success': success,
                'newsletter_html': html_content,
                'diffusion': diffusion,
                'timestamp': datetime.now().isoformat(),
                'test_mode': self.test_mode,
                'articles_collectes': articles_collectes,  # ‚úÖ CL√â AJOUT√âE
                'statistiques': statistiques              # ‚úÖ CL√â AJOUT√âE
            }
            
        except Exception as e:
            logging.error(f"‚ùå Erreur dans le workflow: {e}")
            print(f"ERROR: ‚ùå Erreur dans le workflow: {e}")
            if hasattr(e, '__traceback__') and e.__traceback__:
                print(f"ERROR: üîç Debug: Erreur sur ligne {e.__traceback__.tb_lineno}")
            
            # Retour d'erreur - AVEC TOUTES LES CL√âS REQUISES
            return {
                'success': False,
                'newsletter_html': '',
                'diffusion': {'success': False, 'error': str(e)},
                'timestamp': datetime.now().isoformat(),
                'test_mode': self.test_mode,
                'articles_collectes': [],  # ‚úÖ CL√â AJOUT√âE
                'statistiques': {}         # ‚úÖ CL√â AJOUT√âE
            }
    
    def tester_agents_individuellement(self) -> Dict:
        """Teste chaque agent individuellement pour diagnostiquer les probl√®mes"""
        resultats = {
            'agent_veille': {'statut': 'non_teste', 'details': None},
            'agent_redacteur': {'statut': 'non_teste', 'details': None},
            'agent_redacteur_chef': {'statut': 'non_teste', 'details': None},
            'agent_template': {'statut': 'non_teste', 'details': None},
            'agent_mailchimp': {'statut': 'non_teste', 'details': None}
        }
        
        articles = None
        contenu = None
        contenu_final = None
        
        # Test Agent Veille
        try:
            logging.info("Test Agent Veille...")
            articles = self.agent_veille.collecter_articles(limit=3)
        
            resultats['agent_veille'] = {
                'statut': 'succ√®s' if articles else '√©chec',
                'details': f"{len(articles)} articles collect√©s" if articles else "Aucun article collect√©"
            }
        except Exception as e:
            resultats['agent_veille'] = {'statut': 'erreur', 'details': str(e)}
        
        # Test Agent R√©dacteur
        if resultats['agent_veille']['statut'] == 'succ√®s' and articles:
            try:
                logging.info("Test Agent R√©dacteur...")
                tendances = self.agent_veille.analyser_tendances(articles)
                contenu = self.agent_redacteur.rediger_contenu(articles[:2], tendances)
                resultats['agent_redacteur'] = {
                    'statut': 'succ√®s' if contenu else '√©chec',
                    'details': f"Contenu g√©n√©r√©: {len(str(contenu))} caract√®res" if contenu else "Aucun contenu g√©n√©r√©"
                }
            except Exception as e:
                resultats['agent_redacteur'] = {'statut': 'erreur', 'details': str(e)}
        
        # Test Agent R√©dacteur Chef
        if resultats['agent_redacteur']['statut'] == 'succ√®s' and contenu:
            try:
                logging.info("Test Agent R√©dacteur Chef...")
                contenu_final = self.agent_redacteur_chef.finaliser_newsletter(contenu)
                resultats['agent_redacteur_chef'] = {
                    'statut': 'succ√®s' if contenu_final else '√©chec',
                    'details': f"Newsletter finalis√©e" if contenu_final else "√âchec finalisation"
                }
            except Exception as e:
                resultats['agent_redacteur_chef'] = {'statut': 'erreur', 'details': str(e)}
        
        # Test Agent Template
        if resultats['agent_redacteur_chef']['statut'] == 'succ√®s' and contenu_final:
            try:
                logging.info("Test Agent Template...")
                html = self.agent_template.generer_html(contenu_final)
                resultats['agent_template'] = {
                    'statut': 'succ√®s' if html else '√©chec',
                    'details': f"HTML g√©n√©r√©: {len(str(html))} caract√®res" if html else "Aucun HTML g√©n√©r√©"
                }
            except Exception as e:
                resultats['agent_template'] = {'statut': 'erreur', 'details': str(e)}
        
        # Test Agent Mailchimp
        try:
            logging.info("Test Agent Mailchimp...")
            test_result = self.agent_mailchimp.test_envoi()  # Utilise la nouvelle m√©thode
            resultats['agent_mailchimp'] = {
                'statut': 'succ√®s' if test_result else '√©chec',
                'details': f"Test envoi: {'R√©ussi' if test_result else '√âchec'}"
            }
        except Exception as e:
            resultats['agent_mailchimp'] = {'statut': 'erreur', 'details': str(e)}
        
        return resultats
    
    def generer_rapport_diagnostic(self) -> str:
        """G√©n√®re un rapport de diagnostic complet du syst√®me"""
        resultats = self.tester_agents_individuellement()
        
        rapport = [
            "üîç RAPPORT DE DIAGNOSTIC - NEWSLETTER PRIZMAI",
            "=" * 50,
            f"üìÖ G√©n√©r√© le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"üß™ Mode test: {'Activ√©' if self.test_mode else 'D√©sactiv√©'}",
            "",
            "üìä STATUT DES AGENTS:",
            "-" * 25
        ]
        
        for agent, result in resultats.items():
            statut_emoji = {
                'succ√®s': '‚úÖ',
                '√©chec': '‚ö†Ô∏è',
                'erreur': '‚ùå',
                'non_teste': '‚è∏Ô∏è'
            }
            emoji = statut_emoji.get(result['statut'], '‚ùì')
            rapport.append(f"{emoji} {agent.replace('_', ' ').title()}: {result['statut'].upper()}")
            if result['details']:
                rapport.append(f"   ‚îî‚îÄ {result['details']}")
        
        # Statistiques globales
        total_agents = len(resultats)
        agents_ok = sum(1 for r in resultats.values() if r['statut'] == 'succ√®s')
        
        rapport.extend([
            "",
            "üìà STATISTIQUES GLOBALES:",
            "-" * 25,
            f"üìä Agents fonctionnels: {agents_ok}/{total_agents}",
            f"üìä Taux de r√©ussite: {(agents_ok/total_agents)*100:.1f}%",
            "",
            "üéØ RECOMMANDATIONS:",
            "-" * 20
        ])
        
        if agents_ok == total_agents:
            rapport.append("‚úÖ Tous les agents sont fonctionnels - Le syst√®me est pr√™t")
        else:
            rapport.append("‚ö†Ô∏è Certains agents n√©cessitent une attention:")
            for agent, result in resultats.items():
                if result['statut'] != 'succ√®s':
                    rapport.append(f"   ‚Ä¢ Corriger {agent.replace('_', ' ')}: {result['details']}")
        
        return "\n".join(rapport)
