// pipeline-v4-fixed.js - Pipeline corrig√© avec g√©n√©ration automatique de veille
require('dotenv').config({ path: './config/.env' });
const PRIZM_CONFIG = require('./config/prizm-config.cjs');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

// Import des utilitaires
const DateHelper = require('./utils/date-helper.cjs');
const VeilleParser = require('./utils/veille-parser.cjs');
const SujetScorer = require('./utils/sujet-scorer.cjs');

// Configuration
// Configuration d√©plac√©e vers prizm-config.js
const CONFIG = {
  AGENTS: {
    veille: './agent-veille-v4.cjs',
    redacteurFactuel: './agent-redacteur-factuel.cjs',
    styleConversationnel: './agent-style-conversationnel.cjs'
  },
  STRUCTURE: {
    base: './output',
    veille: '01-veille',
    corpus: '02-corpus',
    factuels: '03-articles-factuels',
    conversationnels: '04-articles-conversationnels',
    finaux: '05-articles-finaux',
    rapports: '06-rapports',
    archives: '07-archives'
  },
  VALIDATION: {
    longueurMin: 1200,
    longueurMax: 1800,
    longueurCible: 1500
  },
  OPTIONS: {
    archiver: true,
    genererRapport: true,
    afficherStats: true
  }
};

class PipelinePrizmV4 {
  constructor() {
    this.sessionId = this.genererSessionId();
    this.stats = {
      debut: Date.now(),
      etapes: [],
      resultats: {
        veille: null,
        corpus: null,
        articleFactuel: null,
        articleConversationnel: null
      }
    };
    this.scorer = new SujetScorer();
    this.parser = new VeilleParser();
  }

  genererSessionId() {
    const date = new Date();
    return date.toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '-');
  }

  async initialiser() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              PIPELINE PRIZM AI v4                     ‚ïë
‚ïë          Double sortie : Factuel + Conversationnel    ‚ïë
‚ïë                                                       ‚ïë
‚ïë  Session : ${this.sessionId}                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);

    // Cr√©er la structure des dossiers
    await this.creerStructure();
    
    // V√©rifier les agents
    await this.verifierAgents();
    
    console.log('\n‚úÖ Pipeline initialis√©\n');
    return true;
  }

  async creerStructure() {
    console.log('üìÅ Cr√©ation de la structure...');
    
    for (const [key, dossier] of Object.entries(CONFIG.STRUCTURE)) {
      if (key !== 'base') {
        const chemin = path.join(CONFIG.STRUCTURE.base, dossier);
        await fs.mkdir(chemin, { recursive: true });
      }
    }
    
    // Cr√©er aussi les sous-dossiers n√©cessaires
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    
    // Cr√©er le dossier de veille du jour
    const veilleJour = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.veille, dateStr.substring(0, 7), dateStr);
    await fs.mkdir(veilleJour, { recursive: true });
    
    // Dossier de session pour archives
    this.dossierSession = path.join(
      CONFIG.STRUCTURE.base,
      CONFIG.STRUCTURE.archives,
      this.sessionId
    );
    await fs.mkdir(this.dossierSession, { recursive: true });
  }

  async verifierAgents() {
    console.log('üîç V√©rification des agents...');
    
    for (const [nom, fichier] of Object.entries(CONFIG.AGENTS)) {
      try {
        await fs.access(fichier);
        console.log(`   ‚úì ${nom}`);
      } catch {
        throw new Error(`Agent ${nom} introuvable : ${fichier}`);
      }
    }
  }

  // === √âTAPE 1 : VEILLE ET S√âLECTION (CORRIG√âE) ===
  async etapeVeille(forceNouvelle = false) {
    console.log(`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     √âTAPE 1 : VEILLE & S√âLECTION       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    `);

    let fichierVeille = null;
    let doitGenererVeille = forceNouvelle;
    
    // Si pas de nouvelle veille forc√©e, chercher la derni√®re
    if (!forceNouvelle) {
      console.log('üìã Recherche de la derni√®re veille...\n');
      
      try {
        // Chercher r√©cursivement dans tous les sous-dossiers
        fichierVeille = await this.trouverDerniereVeille();
        
        if (fichierVeille) {
          console.log(`üìÑ Veille trouv√©e : ${path.basename(fichierVeille)}`);
          
          // V√©rifier l'√¢ge du fichier
          const stats = await fs.stat(fichierVeille);
          const ageHeures = (Date.now() - stats.mtime) / (1000 * 60 * 60);
          
          if (ageHeures > 24) {
            console.log(`‚ö†Ô∏è  Veille dat√©e de plus de 24h (${Math.round(ageHeures)}h)`);
            console.log('üîÑ G√©n√©ration d\'une nouvelle veille recommand√©e\n');
          }
        } else {
          console.log('‚ùå Aucune veille existante trouv√©e');
          doitGenererVeille = true;
        }
      } catch (error) {
        console.log('‚ö†Ô∏è  Erreur recherche veille :', error.message);
        doitGenererVeille = true;
      }
    }
    
    // G√©n√©rer une nouvelle veille si n√©cessaire
    if (doitGenererVeille) {
      console.log('üîç G√©n√©ration d\'une nouvelle veille...\n');
      const debut = Date.now();
      
      try {
        const { stdout, stderr } = await execPromise(`node ${CONFIG.AGENTS.veille}`);
        
        if (stderr) {
          console.log('‚ö†Ô∏è  Avertissements veille :', stderr);
        }
        
        // Attendre un peu que le fichier soit bien √©crit
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Retrouver le fichier g√©n√©r√©
        fichierVeille = await this.trouverDerniereVeille();
        
        if (!fichierVeille) {
          throw new Error('Fichier de veille g√©n√©r√© mais introuvable');
        }
        
        this.stats.etapes.push({
          nom: 'veille',
          duree: Date.now() - debut,
          succes: true
        });
        
        console.log(`\n‚úÖ Nouvelle veille g√©n√©r√©e en ${Math.round((Date.now() - debut) / 1000)}s`);
        
      } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration veille :', error.message);
        this.stats.etapes.push({
          nom: 'veille',
          duree: Date.now() - debut,
          succes: false,
          erreur: error.message
        });
        throw error;
      }
    }
    
    if (!fichierVeille) {
      throw new Error('Impossible d\'obtenir un fichier de veille');
    }
    
    console.log(`\nüìÑ Utilisation de : ${path.basename(fichierVeille)}`);
    
    // Parser et scorer les sujets
    const contenuVeille = await fs.readFile(fichierVeille, 'utf-8');
    
    // Parser avec le bon format
    const resultatParse = await this.parser.parseVeilleFile(fichierVeille);
    
    if (!resultatParse || !resultatParse.sujets || resultatParse.sujets.length === 0) {
      throw new Error('Aucun sujet trouv√© dans la veille');
    }
    
    const sujets = resultatParse.sujets;
    console.log(`\nüìä ${sujets.length} sujets trouv√©s`);
    
    // Scorer et trier
    const sujetsScores = sujets.map(sujet => {
      const score = this.scorer.calculateScore(sujet);
      return score;
    }).sort((a, b) => b.score - a.score);
    
    // Afficher le top 3
    console.log('\nüèÜ Top 3 des sujets :');
    sujetsScores.slice(0, 3).forEach((sujet, i) => {
      console.log(`\n${i + 1}. ${sujet.titre}`);
      console.log(`   Score : ${sujet.score}/${sujet.scoreMax}`);
      if (sujet.priorite) {
        console.log(`   Priorit√© : ${sujet.priorite}`);
      }
    });
    
    // S√©lection du meilleur sujet
    const sujetSelectionne = await this.selectionnerSujet(sujetsScores, fichierVeille);
    
    this.stats.resultats.veille = {
      fichier: fichierVeille,
      nbSujets: sujets.length,
      sujetChoisi: sujetSelectionne.titre
    };
    
    return sujetSelectionne;
  }

  
  async trouverDerniereVeille() {
    const dossierVeille = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.veille);
    
    async function trouverFichiersMd(dir) {
      let fichiers = [];
      
      try {
        const entrees = await fs.readdir(dir, { withFileTypes: true });
        
        for (const entree of entrees) {
          const cheminComplet = path.join(dir, entree.name);
          
          if (entree.isDirectory()) {
            const sousFichiers = await trouverFichiersMd(cheminComplet);
            fichiers = fichiers.concat(sousFichiers);
          } else if (entree.isFile() && entree.name.startsWith('veille-') && entree.name.endsWith('.md')) {
            // Extraire la date du nom du fichier
            const dateMatch = entree.name.match(/veille-(\d{4}-\d{2}-\d{2})/);
            if (dateMatch) {
              fichiers.push({
                chemin: cheminComplet,
                date: dateMatch[1],
                dateObj: new Date(dateMatch[1])
              });
            }
          }
        }
      } catch (error) {
        // Ignorer les erreurs
      }
      
      return fichiers;
    }
    
    const tousLesFichiers = await trouverFichiersMd(dossierVeille);
    
    if (tousLesFichiers.length === 0) {
      return null;
    }
    
    // Trier par DATE dans le nom (pas par date de modification)
    tousLesFichiers.sort((a, b) => b.dateObj - a.dateObj);
    
    console.log(`   Derni√®re veille : ${tousLesFichiers[0].date}`);
    return tousLesFichiers[0].chemin;
  }

  async selectionnerSujet(sujets, fichierVeille) {
    // Pour l'instant, on prend le premier
    const sujet = sujets[0];
    
    console.log(`\n‚úÖ Sujet s√©lectionn√© : "${sujet.titre}"`);
    
    // Trouver le dossier corpus correspondant
    // D'abord essayer avec la date du fichier de veille
    const dateMatch = path.basename(fichierVeille).match(/veille-(\d{4}-\d{2}-\d{2})/);
    const dateVeille = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];
    
    const dossierCorpus = path.join(
      CONFIG.STRUCTURE.base,
      CONFIG.STRUCTURE.corpus,
      dateVeille
    );
    
    try {
      const dossiers = await fs.readdir(dossierCorpus);
      const titreSanitize = sujet.titre.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .substring(0, 50);
      
      // Chercher un dossier qui pourrait correspondre
      const dossierSujet = dossiers.find(d => {
        const dLower = d.toLowerCase();
        return dLower.includes(titreSanitize) || 
               dLower.includes(sujet.numero) ||
               titreSanitize.split('-').some(mot => mot.length > 3 && dLower.includes(mot));
      });
      
      if (dossierSujet) {
        sujet.corpusPath = path.join(dossierCorpus, dossierSujet);
        console.log(`üìö Corpus trouv√© : ${dossierSujet}`);
      } else {
        console.log('‚ö†Ô∏è  Corpus non trouv√©, g√©n√©ration avec le titre seul');
      }
    } catch (error) {
      console.log('‚ö†Ô∏è  Pas de corpus disponible pour ce sujet');
    }
    
    return sujet;
  }

  // Le reste du code reste identique...
  // [Copier toutes les autres m√©thodes depuis le pipeline-v4.js original]
  
  async etapeRedactionFactuelle(sujet) {
    console.log(`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     √âTAPE 2 : R√âDACTION FACTUELLE      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    `);

    const debut = Date.now();
    
    // Pr√©parer la commande
    const commande = sujet.corpusPath 
      ? `node ${CONFIG.AGENTS.redacteurFactuel} "${sujet.corpusPath}"`
      : `node ${CONFIG.AGENTS.redacteurFactuel} --titre "${sujet.titre}"`;
    
    console.log('‚úçÔ∏è  G√©n√©ration de l\'article factuel...\n');
    
    try {
      const { stdout } = await execPromise(commande);
      
      // Trouver l'article g√©n√©r√©
      const dossierFactuels = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.factuels);
      const fichiers = await fs.readdir(dossierFactuels);
      const dernierArticle = fichiers
        .filter(f => f.endsWith('.md'))
        .sort()
        .pop();
      
      if (!dernierArticle) {
        throw new Error('Article factuel non g√©n√©r√©');
      }
      
      const cheminArticle = path.join(dossierFactuels, dernierArticle);
      
      // Valider l'article
      const validation = await this.validerArticle(cheminArticle);
      
      console.log(`\n‚úÖ Article factuel g√©n√©r√© : ${dernierArticle}`);
      console.log(`üìè Longueur : ${validation.mots} mots ${validation.statut}`);
      
      this.stats.etapes.push({
        nom: 'redaction-factuelle',
        duree: Date.now() - debut,
        succes: true
      });
      
      this.stats.resultats.articleFactuel = {
        fichier: dernierArticle,
        chemin: cheminArticle,
        mots: validation.mots,
        validation: validation.statut
      };
      
      return cheminArticle;
      
    } catch (error) {
      console.error('‚ùå Erreur r√©daction :', error.message);
      this.stats.etapes.push({
        nom: 'redaction-factuelle',
        duree: Date.now() - debut,
        succes: false,
        erreur: error.message
      });
      throw error;
    }
  }

  async etapeStyleConversationnel(articleFactuel, activer = true) {
    if (!activer) {
      console.log('\n‚è≠Ô∏è  Style conversationnel d√©sactiv√©');
      return null;
    }
    
    console.log(`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   √âTAPE 3 : STYLE CONVERSATIONNEL      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    `);

    const debut = Date.now();
    
    console.log('üó£Ô∏è  Application du style conversationnel...\n');
    
    try {
      await execPromise(`node ${CONFIG.AGENTS.styleConversationnel} "${articleFactuel}"`);
      
      // L'agent style sauvegarde dans 05-articles-finaux
      const dossierFinaux = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.conversationnels);
      const fichiers = await fs.readdir(dossierFinaux);
      const articleConversationnel = fichiers
        .filter(f => f.includes('conversationnel') && f.endsWith('.md'))
        .sort()
        .pop();
      
      if (!articleConversationnel) {
        throw new Error('Article conversationnel non g√©n√©r√©');
      }
      
      const cheminArticle = path.join(dossierFinaux, articleConversationnel);
      
      // D√©placer vers le bon dossier
      const nouveauChemin = path.join(
        CONFIG.STRUCTURE.base,
        CONFIG.STRUCTURE.conversationnels,
        articleConversationnel
      );
      await fs.rename(cheminArticle, nouveauChemin);
      
      console.log(`\n‚úÖ Article conversationnel g√©n√©r√© : ${articleConversationnel}`);
      
      this.stats.etapes.push({
        nom: 'style-conversationnel',
        duree: Date.now() - debut,
        succes: true
      });
      
      this.stats.resultats.articleConversationnel = {
        fichier: articleConversationnel,
        chemin: nouveauChemin
      };
      
      return nouveauChemin;
      
    } catch (error) {
      console.error('‚ùå Erreur style :', error.message);
      this.stats.etapes.push({
        nom: 'style-conversationnel',
        duree: Date.now() - debut,
        succes: false,
        erreur: error.message
      });
      // Non bloquant - on continue avec juste l'article factuel
      return null;
    }
  }

  async validerArticle(cheminArticle) {
    const contenu = await fs.readFile(cheminArticle, 'utf-8');
    const mots = contenu.split(/\s+/).length;
    
    const validation = {
      mots,
      longueurOk: mots >= CONFIG.VALIDATION.longueurMin && 
                  mots <= CONFIG.VALIDATION.longueurMax,
      sources: contenu.includes('Source :'),
      structure: contenu.includes('##'),
      statut: ''
    };
    
    if (validation.longueurOk && validation.sources && validation.structure) {
      validation.statut = '‚úÖ';
    } else if (mots < CONFIG.VALIDATION.longueurMin) {
      validation.statut = '‚ö†Ô∏è (trop court)';
    } else if (mots > CONFIG.VALIDATION.longueurMax) {
      validation.statut = '‚ö†Ô∏è (trop long)';
    } else {
      validation.statut = '‚ùå (structure)';
    }
    
    return validation;
  }

  async finaliser() {
    console.log(`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          FINALISATION                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    `);

    // Copier les articles finaux
    const articlesFinaux = [];
    
    if (this.stats.resultats.articleFactuel) {
      const destination = path.join(
        CONFIG.STRUCTURE.base,
        CONFIG.STRUCTURE.finaux,
        this.stats.resultats.articleFactuel.fichier
      );
      await fs.copyFile(
        this.stats.resultats.articleFactuel.chemin,
        destination
      );
      articlesFinaux.push({
        type: 'factuel',
        fichier: this.stats.resultats.articleFactuel.fichier
      });
    }
    
    if (this.stats.resultats.articleConversationnel) {
      const destination = path.join(
        CONFIG.STRUCTURE.base,
        CONFIG.STRUCTURE.finaux,
        this.stats.resultats.articleConversationnel.fichier
      );
      await fs.copyFile(
        this.stats.resultats.articleConversationnel.chemin,
        destination
      );
      articlesFinaux.push({
        type: 'conversationnel',
        fichier: this.stats.resultats.articleConversationnel.fichier
      });
    }
    
    // G√©n√©rer le rapport
    if (CONFIG.OPTIONS.genererRapport) {
      await this.genererRapport();
    }
    
    // Archiver la session
    if (CONFIG.OPTIONS.archiver) {
      await this.archiverSession();
    }
    
    // Afficher le r√©sum√©
    this.afficherResume(articlesFinaux);
    
    return articlesFinaux;
  }

  async genererRapport() {
    const rapport = {
      session: this.sessionId,
      timestamp: new Date().toISOString(),
      pipeline: 'v4',
      dureeTotal: Date.now() - this.stats.debut,
      etapes: this.stats.etapes,
      resultats: this.stats.resultats,
      configuration: CONFIG
    };
    
    const cheminRapport = path.join(
      CONFIG.STRUCTURE.base,
      CONFIG.STRUCTURE.rapports,
      `rapport-${this.sessionId}.json`
    );
    
    await fs.writeFile(cheminRapport, JSON.stringify(rapport, null, 2));
    console.log(`\nüìä Rapport g√©n√©r√© : ${path.basename(cheminRapport)}`);
    
    // Version Markdown lisible
    let md = `# Rapport Pipeline v4 - ${this.sessionId}\n\n`;
    md += `**Date** : ${new Date().toLocaleString('fr-FR')}\n`;
    md += `**Dur√©e totale** : ${Math.round((Date.now() - this.stats.debut) / 1000)}s\n\n`;
    
    md += `## R√©sultats\n\n`;
    md += `### Veille\n`;
    md += `- Fichier : ${this.stats.resultats.veille?.fichier || 'N/A'}\n`;
    md += `- Sujets analys√©s : ${this.stats.resultats.veille?.nbSujets || 0}\n`;
    md += `- Sujet choisi : ${this.stats.resultats.veille?.sujetChoisi || 'N/A'}\n\n`;
    
    md += `### Articles g√©n√©r√©s\n`;
    if (this.stats.resultats.articleFactuel) {
      md += `- **Factuel** : ${this.stats.resultats.articleFactuel.fichier}\n`;
      md += `  - Mots : ${this.stats.resultats.articleFactuel.mots}\n`;
      md += `  - Validation : ${this.stats.resultats.articleFactuel.validation}\n`;
    }
    if (this.stats.resultats.articleConversationnel) {
      md += `- **Conversationnel** : ${this.stats.resultats.articleConversationnel.fichier}\n`;
    }
    
    md += `\n## Performance\n\n`;
    md += `| √âtape | Dur√©e | Statut |\n`;
    md += `|-------|-------|--------|\n`;
    this.stats.etapes.forEach(etape => {
      md += `| ${etape.nom} | ${Math.round(etape.duree / 1000)}s | ${etape.succes ? '‚úÖ' : '‚ùå'} |\n`;
    });
    
    const cheminRapportMd = cheminRapport.replace('.json', '.md');
    await fs.writeFile(cheminRapportMd, md);
  }

  async archiverSession() {
    // Copier tous les fichiers importants dans l'archive
    const fichiers = [
      this.stats.resultats.veille?.fichier,
      this.stats.resultats.articleFactuel?.fichier,
      this.stats.resultats.articleConversationnel?.fichier
    ].filter(f => f);
    
    for (const fichier of fichiers) {
      // Logique de copie vers this.dossierSession
    }
    
    console.log(`üì¶ Session archiv√©e : ${path.basename(this.dossierSession)}`);
  }

  afficherResume(articlesFinaux) {
    const dureeTotal = Math.round((Date.now() - this.stats.debut) / 1000);
    
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  PIPELINE TERMIN√â                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä R√âSUM√â DE LA SESSION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚è±Ô∏è  Dur√©e totale : ${dureeTotal}s
üìÑ Articles g√©n√©r√©s : ${articlesFinaux.length}
`);

    articlesFinaux.forEach(article => {
      console.log(`
${article.type === 'factuel' ? 'üìö' : 'üó£Ô∏è'} Article ${article.type} :
   ${article.fichier}
`);
    });

    console.log(`
üìã PROCHAINES √âTAPES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. Relire les articles dans : ${CONFIG.STRUCTURE.base}/${CONFIG.STRUCTURE.finaux}/
2. Choisir la version adapt√©e √† votre objectif :
   - Factuel ‚Üí Pour informer (blog r√©f√©rence, documentation)
   - Conversationnel ‚Üí Pour engager (newsletter, r√©seaux sociaux)
3. Copier dans le blog : C:\\Users\\Samuel\\Documents\\prizmia\\src\\content\\blog\\
4. Publier via git push

‚ú® Pipeline v4 - Simple, efficace, flexible.
`);
  }

  async executer(options = {}) {
    try {
      await this.initialiser();
      
      // √âtape 1 : Veille et s√©lection
      const sujet = await this.etapeVeille(options.nouvelleVeille);
      
      // √âtape 2 : R√©daction factuelle
      const articleFactuel = await this.etapeRedactionFactuelle(sujet);
      
      // √âtape 3 : Style conversationnel (optionnel)
      const articleConversationnel = await this.etapeStyleConversationnel(
        articleFactuel,
        options.styleConversationnel !== false
      );
      
      // Finalisation
      const articlesFinaux = await this.finaliser();
      
      return {
        succes: true,
        articles: articlesFinaux,
        duree: Date.now() - this.stats.debut
      };
      
    } catch (error) {
      console.error('\n‚ùå ERREUR PIPELINE :', error.message);
      
      // Rapport d'erreur
      const rapportErreur = {
        session: this.sessionId,
        timestamp: new Date().toISOString(),
        erreur: error.message,
        stack: error.stack,
        stats: this.stats
      };
      
      const cheminErreur = path.join(
        CONFIG.STRUCTURE.base,
        CONFIG.STRUCTURE.rapports,
        `erreur-${this.sessionId}.json`
      );
      
      await fs.writeFile(cheminErreur, JSON.stringify(rapportErreur, null, 2));
      
      throw error;
    }
  }
}

// === CLI ===
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
üöÄ Pipeline Prizm AI v4 (CORRIG√â)
=================================

Pipeline √©pur√© avec double sortie : factuel et conversationnel.
G√©n√®re automatiquement une veille si aucune n'existe.

Usage :
  node pipeline-v4-fixed.js [options]

Options :
  --nouvelle-veille    Forcer une nouvelle veille (m√™me si une existe)
  --factuel-only       G√©n√©rer uniquement l'article factuel
  --help, -h           Afficher cette aide

Exemples :
  node pipeline-v4-fixed.js                    # Utilise la derni√®re veille OU en g√©n√®re une
  node pipeline-v4-fixed.js --nouvelle-veille  # Force une nouvelle veille
  node pipeline-v4-fixed.js --factuel-only     # Sans style conversationnel

Comportement par d√©faut :
  1. Cherche la derni√®re veille disponible
  2. Si aucune veille ‚Üí g√©n√®re automatiquement
  3. Si veille > 24h ‚Üí propose une nouvelle
  4. G√©n√®re article factuel + conversationnel

Temps moyen : ~2-3 minutes pour pipeline complet
    `);
    process.exit(0);
  }
  
  const pipeline = new PipelinePrizmV4();
  
  const options = {
    nouvelleVeille: args.includes('--nouvelle-veille'),
    styleConversationnel: !args.includes('--factuel-only')
  };
  
  try {
    console.time('‚è±Ô∏è Pipeline complet');
    await pipeline.executer(options);
    console.timeEnd('‚è±Ô∏è Pipeline complet');
    
    process.exit(0);
    
  } catch (error) {
    console.error('\nüí• Pipeline √©chou√©');
    process.exit(1);
  }
}

// Export pour utilisation programmatique
module.exports = PipelinePrizmV4;

// Lancer si ex√©cut√© directement
if (require.main === module) {
  main();
}