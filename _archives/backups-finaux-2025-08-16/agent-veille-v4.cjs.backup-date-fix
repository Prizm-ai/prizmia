// agent-veille-v4-complete.js - Version compl√®te avec toutes les m√©thodes
require('dotenv').config({ path: './config/.env' });
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
const DateHelper = require('./utils/date-helper.cjs');
const SujetScorer = require('./utils/sujet-scorer.cjs');

// Configuration
const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
const PERPLEXITY_API_URL = 'https://api.perplexity.ai/chat/completions';

const CONFIG = {
  MIN_SOURCES: 3,
  MIN_EXTRAITS_PAR_SOURCE: 5,        
  MAX_SOURCES: 5,        
  CORPUS_DIR: './output/02-corpus',
  QUALITY_THRESHOLD: 0.5,
  SOURCE_TYPES: {
    NEWS: { weight: 0.3, keywords: ['actualit√©', 'news', 'annonce'] },
    STUDY: { weight: 0.4, keywords: ['√©tude', 'rapport', 'analyse'] },
    CASE: { weight: 0.3, keywords: ['cas client', 'retour exp√©rience', 'exemple'] }
  }
};

// Master Prompt pour la veille multi-sources
const MASTER_PROMPT_VEILLE_V4 = `Tu es un expert en veille technologique sp√©cialis√© dans l'IA et la transformation digitale des PME/ETI fran√ßaises.

MISSION : Identifier et analyser 5 sujets d'actualit√© IA pertinents pour des dirigeants de PME/ETI, en collectant 3-5 sources v√©rifiables par sujet.

CRIT√àRES DE S√âLECTION :
1. Actualit√© r√©cente (< 7 jours id√©alement)
2. Impact business concret et mesurable
3. Applicable aux PME/ETI fran√ßaises
4. Sources fiables et v√©rifiables

STRUCTURE POUR CHAQUE SUJET :

## N. [TITRE DU SUJET]

### Sources v√©rifi√©es
**Source 1** : [Nom de la source] ‚Äì [Type : Article/√âtude/Rapport]
- URL : [URL compl√®te et exacte]
- Date : [JJ/MM/AAAA]
- Fiabilit√© : [X/10] ([justification courte])
- Extraits cl√©s (MINIMUM 5 extraits d√©taill√©s) :
  * "[Citation exacte 1]"
  * "[Citation exacte 2]"
- Donn√©es factuelles : [Chiffres, pourcentages, montants avec contexte]

[R√©p√©ter pour chaque source]

### Synth√®se et angles
- **Convergences** : [Points communs entre sources]
- **Divergences** : [Diff√©rences notables]
- **Angle Prizm recommand√©** : [Approche business pour PME/ETI]
- **Score global** : [X/10]

R√àGLES IMP√âRATIVES :
- MINIMUM 3 sources par sujet, id√©alement 4-5
- URLs compl√®tes et fonctionnelles obligatoires
- Citations exactes entre guillemets
- Dates pr√©cises pour chaque source
- Fiabilit√© √©valu√©e objectivement

DOMAINES PRIORITAIRES :
1. IA g√©n√©rative et productivit√©
2. Automatisation des processus
3. Cybers√©curit√© et IA
4. Formation et comp√©tences IA
5. Retours d'exp√©rience PME
6. Financements et aides publiques
7. R√©glementation et conformit√© IA

Format de sortie : Markdown structur√© avec m√©tadonn√©es compl√®tes.`;

class AgentVeilleV4 {
  constructor() {
    this.resultats = null;
    this.sujetsRetenus = [];
  }

  async executer(options = {}) {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            AGENT VEILLE v4 - MULTI-SOURCES             ‚ïë
‚ïë         Collecte et v√©rification des sources           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);

    try {
      // Lancer la recherche
      const contenu = await this.lancerRecherche(options);
      
      // Parser les sujets avec leurs sources
      const sujets = await this.parserSujetsAvecSources(contenu);
      
      // Sauvegarder les r√©sultats
      await this.sauvegarderVeille(contenu, sujets);
      
      // IMPORTANT : TOUJOURS cr√©er le corpus pour chaque sujet retenu
      console.log('\nüìö Cr√©ation automatique des corpus...');
      for (const sujet of this.sujetsRetenus) {
        const corpusPath = await this.creerCorpusVerifie(sujet);
        sujet.corpusPath = corpusPath; // Ajouter le chemin du corpus au sujet
      }
      
      console.log(`\n‚úÖ Veille termin√©e : ${this.sujetsRetenus.length} sujets avec corpus`);
      
      return {
        success: true,
        sujets: this.sujetsRetenus,
        fichierVeille: this.resultats.fichierVeille
      };
      
    } catch (error) {
      console.error('‚ùå Erreur veille :', error.message);
      throw error;
    }
  }

  async lancerRecherche(options) {
    console.log('\nüîç Lancement de la recherche Perplexity...\n');
    
    const promptFinal = options.complet 
      ? MASTER_PROMPT_VEILLE_V4 + '\n\nRecherche APPROFONDIE sur TOUS les domaines list√©s.'
      : MASTER_PROMPT_VEILLE_V4 + '\n\nFocus sur les 3-4 sujets les plus pertinents cette semaine.';
    
    try {
      const response = await axios.post(
        PERPLEXITY_API_URL,
        {
          model: 'sonar',
          messages: [
            {
              role: 'system',
              content: 'Tu es un expert en veille IA pour PME/ETI. Fournis TOUJOURS des URLs compl√®tes, AU MINIMUM 5 citations longues par source, et 3-4 donn√©es chiffr√©es d√©taill√©es.'
            },
            {
              role: 'user',
              content: promptFinal
            }
          ],
          temperature: 0.2,
          max_tokens: 4000
        },
        {
          headers: {
            'Authorization': `Bearer ${PERPLEXITY_API_KEY}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.choices[0].message.content;
      
    } catch (error) {
      console.error('‚ùå Erreur API Perplexity :', error.response?.data || error.message);
      throw error;
    }
  }

  async parserSujetsAvecSources(contenu) {
    const sujets = [];
    const regexSujet = /## (\d+)\. (.+?)(?=\n## \d+\.|\n---|$)/gs;
    
    console.log('üìã Parsing des sujets et sources...\n');
    
    let match;
    const matches = [];
    
    while ((match = regexSujet.exec(contenu)) !== null) {
      matches.push({
        numero: match[1],
        titre: match[2].trim(),
        startIndex: match.index,
        matchLength: match[0].length
      });
    }
    
    console.log(`   Sujets trouv√©s : ${matches.length}`);
    
    for (let i = 0; i < matches.length; i++) {
      const current = matches[i];
      const nextIndex = matches[i + 1] ? matches[i + 1].startIndex : contenu.length;
      const contenuSujet = contenu.substring(current.startIndex, nextIndex);
      
      console.log(`\n   üìå Sujet ${current.numero} : ${current.titre}`);
      
      // Extraire les sources
      const sources = this.extraireSources(contenuSujet);
      console.log(`      Sources trouv√©es : ${sources.length}`);
      
      // Extraire la synth√®se et les angles
      const synthese = this.extraireSynthese(contenuSujet);
      
      // Calculer le score de qualit√©
      const scoreQualite = this.calculerScoreQualiteSources(sources);
      
      // D√©cision
      if (sources.length >= CONFIG.MIN_SOURCES && scoreQualite >= CONFIG.QUALITY_THRESHOLD) {
        sujets.push({
          numero: current.numero,
          titre: current.titre,
          sources,
          synthese,
          scoreQualite,
          timestamp: new Date().toISOString()
        });
        console.log(`      ‚úÖ Sujet retenu (score: ${scoreQualite.toFixed(2)})`);
      } else {
        console.log(`      ‚ùå Sujet rejet√© (sources: ${sources.length}/${CONFIG.MIN_SOURCES}, score: ${scoreQualite.toFixed(2)})`);
      }
    }
    
    this.sujetsRetenus = sujets;
    return sujets;
  }

  extraireSources(contenuSujet) {
    const sources = [];
    const regexSource = /\*\*Source (\d+)\*\* : (.+?) ‚Äì (.+?)\n([\s\S]+?)(?=\*\*Source \d+|### Synth√®se|$)/g;
    
    let match;
    while ((match = regexSource.exec(contenuSujet)) !== null) {
      const sourceData = {
        numero: parseInt(match[1]),
        nom: match[2].trim(),
        type: match[3].trim(),
        url: '',
        date: '',
        fiabilite: 7,
        extraits: [],
        donnees: []
      };
      
      const contenuSource = match[4];
      
      // Extraire URL
      const urlMatch = contenuSource.match(/- URL : (.+)/);
      if (urlMatch) sourceData.url = urlMatch[1].trim();
      
      // Extraire date
      const dateMatch = contenuSource.match(/- Date : (.+)/);
      if (dateMatch) sourceData.date = dateMatch[1].trim();
      
      // Extraire fiabilit√©
      const fiabiliteMatch = contenuSource.match(/- Fiabilit√© : (\d+)\/10/);
      if (fiabiliteMatch) sourceData.fiabilite = parseInt(fiabiliteMatch[1]);
      
      // Extraire citations
      const citationsMatch = contenuSource.matchAll(/\* "([^"]+)"/g);
      for (const citation of citationsMatch) {
        sourceData.extraits.push(citation[1]);
      }
      
      // Extraire donn√©es factuelles
      const donneesMatch = contenuSource.match(/- Donn√©es factuelles : (.+)/);
      if (donneesMatch) {
        sourceData.donnees = donneesMatch[1].split(',').map(d => d.trim());
      }
      
      sources.push(sourceData);
    }
    
    return sources;
  }

  extraireSynthese(contenuSujet) {
    const synthese = {
      convergences: '',
      divergences: '',
      anglePrizm: '',
      scoreGlobal: 0
    };
    
    const syntheseMatch = contenuSujet.match(/### Synth√®se et angles([\s\S]+?)$/);
    if (syntheseMatch) {
      const contenuSynthese = syntheseMatch[1];
      
      const convergencesMatch = contenuSynthese.match(/\*\*Convergences\*\* : (.+)/);
      if (convergencesMatch) synthese.convergences = convergencesMatch[1].trim();
      
      const divergencesMatch = contenuSynthese.match(/\*\*Divergences\*\* : (.+)/);
      if (divergencesMatch) synthese.divergences = divergencesMatch[1].trim();
      
      const angleMatch = contenuSynthese.match(/\*\*Angle Prizm recommand√©\*\* : (.+)/);
      if (angleMatch) synthese.anglePrizm = angleMatch[1].trim();
      
      const scoreMatch = contenuSynthese.match(/\*\*Score global\*\* : (\d+)\/10/);
      if (scoreMatch) synthese.scoreGlobal = parseInt(scoreMatch[1]);
    }
    
    return synthese;
  }

  calculerScoreQualiteSources(sources) {
    if (sources.length === 0) return 0;
    
    // 1. Moyenne de fiabilit√©
    const fiabiliteMoyenne = sources.reduce((sum, s) => sum + s.fiabilite, 0) / sources.length;
    
    // 2. Nombre de sources (bonus si > minimum)
    const scoreNombre = Math.min(sources.length / CONFIG.MIN_SOURCES, 1.5);
    
    // 3. Richesse du contenu
    let totalExtraits = 0;
    let totalDonnees = 0;
    sources.forEach(s => {
      totalExtraits += (s.extraits || []).length;
      totalDonnees += (s.donnees || []).length;
    });
    const richesseMoyenne = (totalExtraits + totalDonnees) / sources.length;
    const scoreRichesse = Math.min(richesseMoyenne / 5, 1);
    
    // 4. Diversit√© des types
    const types = new Set(sources.map(s => s.type || 'Article'));
    const scoreDiversite = types.size >= 2 ? 1 : 0.7;
    
    // Calcul final
    const scoreFinal = (
      (fiabiliteMoyenne / 10) * 0.3 +
      scoreNombre * 0.2 +
      scoreRichesse * 0.3 +
      scoreDiversite * 0.2
    );
    
    return scoreFinal;
  }

  async sauvegarderVeille(contenu, sujets) {
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    const outputPath = await DateHelper.getPathForType('./output', 'veille', date);
    
    // Sauvegarder le fichier de veille
    const filename = `veille-${dateStr}.md`;
    const filepath = path.join(outputPath, filename);
    
    // Ajouter l'en-t√™te
    let contenuFinal = `# üìä VEILLE PRIZM AI v4 - ${date.toLocaleDateString('fr-FR', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    })}\n\n`;
    
    contenuFinal += `*G√©n√©r√©e avec collecte multi-sources et corpus v√©rifi√©*\n\n`;
    contenuFinal += `---\n\n`;
    contenuFinal += `## üéØ Synth√®se ex√©cutive\n\n`;
    contenuFinal += `${sujets.length} sujets analys√©s avec ${sujets.reduce((acc, s) => acc + s.sources.length, 0)} sources v√©rifi√©es.\n`;
    contenuFinal += `Score de qualit√© moyen : ${(sujets.reduce((acc, s) => acc + s.scoreQualite, 0) / sujets.length).toFixed(2)}/1\n\n`;
    contenuFinal += `---\n\n`;
    
    contenuFinal += contenu;
    
    await fs.writeFile(filepath, contenuFinal, 'utf-8');
    console.log(`\nüíæ Veille sauvegard√©e : ${filepath}`);
    
    this.resultats = {
      fichierVeille: filepath,
      date: dateStr,
      sujets: sujets.length
    };
  }

  async creerCorpusVerifie(sujet) {
    console.log(`\nüìö Cr√©ation du corpus pour : ${sujet.titre}`);
    
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    
    // Cr√©er un slug propre pour le dossier
    const titreSanitize = sujet.titre
      .toLowerCase()
      .normalize('NFD')
      .replace(/[ÃÄ-ÕØ]/g, '') // Enlever les accents
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 60);
    
    const corpusDir = path.join(
      CONFIG.CORPUS_DIR,
      dateStr,
      `${sujet.numero}-${titreSanitize}`
    );
    
    await fs.mkdir(corpusDir, { recursive: true });
    
    // Sauvegarder les m√©tadonn√©es
    const metadata = {
      titre: sujet.titre,
      dateCreation: sujet.timestamp,
      scoreQualite: sujet.scoreQualite,
      sources: sujet.sources.map(s => ({
        nom: s.nom,
        type: s.type,
        url: s.url,
        date: s.date,
        fiabilite: s.fiabilite
      })),
      synthese: sujet.synthese
    };
    
    await fs.writeFile(
      path.join(corpusDir, 'metadata.json'),
      JSON.stringify(metadata, null, 2)
    );
    
    // Sauvegarder chaque source
    for (let i = 0; i < sujet.sources.length; i++) {
      const source = sujet.sources[i];
      let contenuSource = `# ${source.nom}\n\n`;
      contenuSource += `**Type** : ${source.type}\n`;
      contenuSource += `**URL** : ${source.url}\n`;
      contenuSource += `**Date** : ${source.date}\n`;
      contenuSource += `**Fiabilit√©** : ${source.fiabilite}/10\n\n`;
      
      if (source.extraits.length > 0) {
        contenuSource += `## Citations\n\n`;
        source.extraits.forEach(e => {
          contenuSource += `* "${e}"\n`;
        });
      }
      
      if (source.donnees.length > 0) {
        contenuSource += `\n## Donn√©es factuelles\n\n`;
        source.donnees.forEach(d => {
          contenuSource += `- ${d}\n`;
        });
      }
      
      await fs.writeFile(
        path.join(corpusDir, `source-${i + 1}-${source.nom.toLowerCase().replace(/[^a-z0-9]+/g, '-')}.md`),
        contenuSource
      );
    }
    
    console.log(`   ‚úÖ Corpus cr√©√© : ${corpusDir}`);
    
    return corpusDir;
  }
}

// Script principal
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
üìö Agent Veille v4 - Multi-sources
==================================

Collecte et v√©rifie des sources multiples pour chaque sujet.

Usage :
  node agent-veille-v4.js [options]

Options :
  --complet    Recherche approfondie multi-domaines
  --help, -h   Affiche cette aide

Fonctionnement :
  1. Recherche 5 sujets d'actualit√© IA
  2. Collecte 3-5 sources par sujet
  3. V√©rifie la qualit√© des sources
  4. Cr√©e un corpus structur√©
  5. Pr√©pare pour la r√©daction factuelle
    `);
    process.exit(0);
  }
  
  const agent = new AgentVeilleV4();
  
  try {
    const options = {
      complet: args.includes('--complet')
    };
    
    console.time('‚è±Ô∏è Dur√©e totale');
    const resultat = await agent.executer(options);
    
    // IMPORTANT : Cr√©er le corpus pour chaque sujet
    if (resultat.sujets && resultat.sujets.length > 0) {
      console.log('\nüìö Cr√©ation des corpus pour les sujets retenus...');
      for (const sujet of resultat.sujets) {
        await agent.creerCorpusVerifie(sujet);
      }
    }
    console.timeEnd('‚è±Ô∏è Dur√©e totale');
    
  } catch (error) {
    console.error('\n‚ùå Erreur :', error.message);
    process.exit(1);
  }
}

// Export pour utilisation dans le pipeline
module.exports = AgentVeilleV4;

// Lancer si ex√©cut√© directement
if (require.main === module) {
  main();
}