// agent-veille-v5.cjs - Version hybride avec mode auto et mode dirig√©
require('dotenv').config({ path: '../config/.env' });
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
const DateHelper = require('../utils/date-helper.cjs');
const SujetScorer = require('../utils/sujet-scorer.cjs');

// Configuration
const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
const PERPLEXITY_API_URL = 'https://api.perplexity.ai/chat/completions';

const CONFIG = {
  MIN_SOURCES: 3,
  MIN_EXTRAITS_PAR_SOURCE: 5,        
  MAX_SOURCES: 5,        
  CORPUS_DIR: './output/02-corpus',
  QUALITY_THRESHOLD: 0.5,
  SOURCE_TYPES: {
    NEWS: { weight: 0.3, keywords: ['actualit√©', 'news', 'annonce'] },
    STUDY: { weight: 0.4, keywords: ['√©tude', 'rapport', 'analyse'] },
    CASE: { weight: 0.3, keywords: ['cas client', 'retour exp√©rience', 'exemple'] }
  }
};

// Prompt pour le mode AUTO (comportement actuel)
const MASTER_PROMPT_AUTO = `Tu es un expert en veille technologique sp√©cialis√© dans l'IA et la transformation digitale des PME/ETI fran√ßaises.

MISSION : Identifier et analyser 5 sujets d'actualit√© IA pertinents pour des dirigeants de PME/ETI, en collectant 3-5 sources v√©rifiables par sujet.

CRIT√àRES DE S√âLECTION :
1. Actualit√© r√©cente (< 7 jours id√©alement)
2. Impact business concret et mesurable
3. Applicable aux PME/ETI fran√ßaises
4. Sources fiables et v√©rifiables

DOMAINES PRIORITAIRES :
1. IA g√©n√©rative et productivit√©
2. Automatisation des processus
3. Cybers√©curit√© et IA
4. Formation et comp√©tences IA
5. Retours d'exp√©rience PME
6. Financements et aides publiques
7. R√©glementation et conformit√© IA`;

// Prompt pour le mode DIRIG√â (nouveau)
const MASTER_PROMPT_DIRIGE = `Tu es un expert en veille technologique sp√©cialis√© dans l'IA et la transformation digitale des PME/ETI fran√ßaises.

MISSION : R√©aliser une veille approfondie sur le sujet sp√©cifique suivant :
"{SUJET}"

OBJECTIFS :
1. Collecter 4-5 sources v√©rifiables et r√©centes sur CE sujet pr√©cis
2. Extraire les informations les plus pertinentes pour les PME/ETI
3. Identifier les angles business et les applications pratiques
4. Fournir des donn√©es chiffr√©es et des exemples concrets

ANGLE √âDITORIAL : {ANGLE}

MOTS-CL√âS POUR LA RECHERCHE : {KEYWORDS}`;

// Structure commune pour les deux modes
const STRUCTURE_VEILLE = `

STRUCTURE POUR CHAQUE SUJET/SOURCE :

### Sources v√©rifi√©es
**Source 1** : [Nom de la source] ‚Äî [Type : Article/√âtude/Rapport]
- URL : [URL compl√®te et exacte]
- Date : [JJ/MM/AAAA]
- Fiabilit√© : [X/10] ([justification courte])
- Extraits cl√©s (MINIMUM 5 extraits d√©taill√©s) :
  * "[Citation exacte 1]"
  * "[Citation exacte 2]"
  * "[Citation exacte 3]"
  * "[Citation exacte 4]"
  * "[Citation exacte 5]"
- Donn√©es factuelles : [Chiffres, pourcentages, montants avec contexte]

[R√©p√©ter pour chaque source]

### Synth√®se et angles
- **Convergences** : [Points communs entre sources]
- **Divergences** : [Diff√©rences notables]
- **Angle Prizm recommand√©** : [Approche business pour PME/ETI]
- **Score global** : [X/10]

R√àGLES IMP√âRATIVES :
- MINIMUM 3 sources par sujet, id√©alement 4-5
- URLs compl√®tes et fonctionnelles obligatoires
- Citations exactes entre guillemets (5 minimum par source)
- Dates pr√©cises pour chaque source
- Fiabilit√© √©valu√©e objectivement`;

class AgentVeilleV5 {
  constructor() {
    this.resultats = null;
    this.sujetsRetenus = [];
    this.mode = 'AUTO'; // AUTO ou DIRIGE
    this.sujetImpose = null;
  }

  /**
   * Point d'entr√©e principal avec support des deux modes
   * @param {Object} options - Options de configuration
   * @param {string} options.mode - 'AUTO' ou 'DIRIGE'
   * @param {Object} options.sujet - Sujet impos√© pour le mode DIRIGE
   */
  async executer(options = {}) {
    this.mode = options.mode || 'AUTO';
    this.sujetImpose = options.sujet || null;
    
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            AGENT VEILLE v5 - MODE ${this.mode.padEnd(7)}          ‚ïë
‚ïë         Collecte et v√©rification des sources           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);

    if (this.mode === 'DIRIGE' && this.sujetImpose) {
      console.log(`\nüéØ Sujet impos√© : ${this.sujetImpose.titre}`);
      console.log(`   Cat√©gorie : ${this.sujetImpose.category || 'actualites'}`);
      console.log(`   Angle : ${this.sujetImpose.angle || 'Analyse pour PME/ETI'}\n`);
    }

    try {
      // Lancer la recherche selon le mode
      const contenu = await this.lancerRecherche(options);
      
      // Parser les r√©sultats
      const sujets = await this.parserResultats(contenu);
      
      // Sauvegarder les r√©sultats
      await this.sauvegarderVeille(contenu, sujets);
      
      // Cr√©er les corpus
      console.log('\nüìö Cr√©ation automatique des corpus...');
      for (const sujet of this.sujetsRetenus) {
        const corpusPath = await this.creerCorpusVerifie(sujet);
        sujet.corpusPath = corpusPath;
      }
      
      console.log(`\n‚úÖ Veille termin√©e : ${this.sujetsRetenus.length} sujet(s) avec corpus`);
      
      return {
        success: true,
        mode: this.mode,
        sujets: this.sujetsRetenus,
        fichierVeille: this.resultats.fichierVeille
      };
      
    } catch (error) {
      console.error('‚ùå Erreur veille :', error.message);
      throw error;
    }
  }

  /**
   * Lancer la recherche selon le mode choisi
   */
  async lancerRecherche(options) {
    console.log(`\nüîç Lancement de la recherche Perplexity (mode ${this.mode})...\n`);
    
    let promptFinal;
    
    if (this.mode === 'DIRIGE' && this.sujetImpose) {
      // Mode dirig√© : recherche sur le sujet impos√©
      promptFinal = MASTER_PROMPT_DIRIGE
        .replace('{SUJET}', this.sujetImpose.titre)
        .replace('{ANGLE}', this.sujetImpose.angle || 'Focus sur les applications pratiques pour PME/ETI')
        .replace('{KEYWORDS}', this.sujetImpose.keywords || 'PME, ETI, France, IA, transformation digitale');
      
      promptFinal += STRUCTURE_VEILLE;
      
    } else {
      // Mode auto : comportement actuel
      promptFinal = MASTER_PROMPT_AUTO + STRUCTURE_VEILLE;
      
      if (options.complet) {
        promptFinal += '\n\nRecherche APPROFONDIE sur TOUS les domaines list√©s.';
      } else {
        promptFinal += '\n\nFocus sur les 3-4 sujets les plus pertinents cette semaine.';
      }
    }
    
    try {
      const response = await axios.post(
        PERPLEXITY_API_URL,
        {
          model: 'sonar',
          messages: [
            {
              role: 'system',
              content: 'Tu es un expert en veille IA pour PME/ETI. Fournis TOUJOURS des URLs compl√®tes, AU MINIMUM 5 citations longues par source, et 3-4 donn√©es chiffr√©es d√©taill√©es.'
            },
            {
              role: 'user',
              content: promptFinal
            }
          ],
          temperature: 0.2,
          max_tokens: 4000
        },
        {
          headers: {
            'Authorization': `Bearer ${PERPLEXITY_API_KEY}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return response.data.choices[0].message.content;
      
    } catch (error) {
      console.error('‚ùå Erreur API Perplexity :', error.response?.data || error.message);
      throw error;
    }
  }

  /**
   * Parser les r√©sultats selon le mode
   */
  async parserResultats(contenu) {
    if (this.mode === 'DIRIGE') {
      // En mode dirig√©, on a UN seul sujet avec plusieurs sources
      return await this.parserSujetUnique(contenu);
    } else {
      // En mode auto, on a plusieurs sujets (comportement actuel)
      return await this.parserSujetsMultiples(contenu);
    }
  }

  /**
   * Parser pour le mode DIRIG√â (un seul sujet)
   */
  async parserSujetUnique(contenu) {
    console.log('üìã Parsing du sujet dirig√© et ses sources...\n');
    
    const sources = this.extraireSources(contenu);
    console.log(`   Sources trouv√©es : ${sources.length}`);
    
    const synthese = this.extraireSynthese(contenu);
    const scoreQualite = this.calculerScoreQualiteSources(sources);
    
    const sujet = {
      numero: '1',
      titre: this.sujetImpose.titre,
      category: this.sujetImpose.category || 'actualites',
      sources,
      synthese,
      scoreQualite,
      timestamp: new Date().toISOString(),
      modeGeneration: 'DIRIGE'
    };
    
    if (sources.length >= CONFIG.MIN_SOURCES && scoreQualite >= CONFIG.QUALITY_THRESHOLD) {
      this.sujetsRetenus = [sujet];
      console.log(`   ‚úÖ Sujet valid√© (score: ${scoreQualite.toFixed(2)})`);
    } else {
      console.log(`   ‚ö†Ô∏è Qualit√© insuffisante mais on garde quand m√™me en mode dirig√©`);
      this.sujetsRetenus = [sujet];
    }
    
    return [sujet];
  }

  /**
   * Parser pour le mode AUTO (plusieurs sujets)
   */
  async parserSujetsMultiples(contenu) {
    const sujets = [];
    const regexSujet = /## (\d+)\. (.+?)(?=\n## \d+\.|\n---|$)/gs;
    
    console.log('üìã Parsing des sujets et sources...\n');
    
    let match;
    const matches = [];
    
    while ((match = regexSujet.exec(contenu)) !== null) {
      matches.push({
        numero: match[1],
        titre: match[2].trim(),
        startIndex: match.index,
        matchLength: match[0].length
      });
    }
    
    console.log(`   Sujets trouv√©s : ${matches.length}`);
    
    for (let i = 0; i < matches.length; i++) {
      const current = matches[i];
      const nextIndex = matches[i + 1] ? matches[i + 1].startIndex : contenu.length;
      const contenuSujet = contenu.substring(current.startIndex, nextIndex);
      
      console.log(`\n   üìå Sujet ${current.numero} : ${current.titre}`);
      
      const sources = this.extraireSources(contenuSujet);
      console.log(`      Sources trouv√©es : ${sources.length}`);
      
      const synthese = this.extraireSynthese(contenuSujet);
      const scoreQualite = this.calculerScoreQualiteSources(sources);
      
      if (sources.length >= CONFIG.MIN_SOURCES && scoreQualite >= CONFIG.QUALITY_THRESHOLD) {
        sujets.push({
          numero: current.numero,
          titre: current.titre,
          sources,
          synthese,
          scoreQualite,
          timestamp: new Date().toISOString(),
          modeGeneration: 'AUTO'
        });
        console.log(`      ‚úÖ Sujet retenu (score: ${scoreQualite.toFixed(2)})`);
      } else {
        console.log(`      ‚ùå Sujet rejet√© (sources: ${sources.length}/${CONFIG.MIN_SOURCES}, score: ${scoreQualite.toFixed(2)})`);
      }
    }
    
    this.sujetsRetenus = sujets;
    return sujets;
  }

  // === M√âTHODES COMMUNES (reprises de la v4) ===
  
  extraireSources(contenuSujet) {
    const sources = [];
    const regexSource = /\*\*Source (\d+)\*\* : (.+?) ‚Äî (.+?)\n([\s\S]+?)(?=\*\*Source \d+|### Synth√®se|$)/g;
    
    let match;
    while ((match = regexSource.exec(contenuSujet)) !== null) {
      const sourceData = {
        numero: parseInt(match[1]),
        nom: match[2].trim(),
        type: match[3].trim(),
        url: '',
        date: '',
        fiabilite: 7,
        extraits: [],
        donnees: []
      };
      
      const contenuSource = match[4];
      
      // Extraire URL
      const urlMatch = contenuSource.match(/- URL : (.+)/);
      if (urlMatch) sourceData.url = urlMatch[1].trim();
      
      // Extraire date
      const dateMatch = contenuSource.match(/- Date : (.+)/);
      if (dateMatch) sourceData.date = dateMatch[1].trim();
      
      // Extraire fiabilit√©
      const fiabiliteMatch = contenuSource.match(/- Fiabilit√© : (\d+)\/10/);
      if (fiabiliteMatch) sourceData.fiabilite = parseInt(fiabiliteMatch[1]);
      
      // Extraire citations
      const citationsMatch = contenuSource.matchAll(/\* "([^"]+)"/g);
      for (const citation of citationsMatch) {
        sourceData.extraits.push(citation[1]);
      }
      
      // Extraire donn√©es factuelles
      const donneesMatch = contenuSource.match(/- Donn√©es factuelles : (.+)/);
      if (donneesMatch) {
        sourceData.donnees = donneesMatch[1].split(',').map(d => d.trim());
      }
      
      sources.push(sourceData);
    }
    
    return sources;
  }

  extraireSynthese(contenuSujet) {
    const synthese = {
      convergences: '',
      divergences: '',
      anglePrizm: '',
      scoreGlobal: 0
    };
    
    const syntheseMatch = contenuSujet.match(/### Synth√®se et angles([\s\S]+?)$/);
    if (syntheseMatch) {
      const contenuSynthese = syntheseMatch[1];
      
      const convergencesMatch = contenuSynthese.match(/\*\*Convergences\*\* : (.+)/);
      if (convergencesMatch) synthese.convergences = convergencesMatch[1].trim();
      
      const divergencesMatch = contenuSynthese.match(/\*\*Divergences\*\* : (.+)/);
      if (divergencesMatch) synthese.divergences = divergencesMatch[1].trim();
      
      const angleMatch = contenuSynthese.match(/\*\*Angle Prizm recommand√©\*\* : (.+)/);
      if (angleMatch) synthese.anglePrizm = angleMatch[1].trim();
      
      const scoreMatch = contenuSynthese.match(/\*\*Score global\*\* : (\d+)\/10/);
      if (scoreMatch) synthese.scoreGlobal = parseInt(scoreMatch[1]);
    }
    
    return synthese;
  }

  calculerScoreQualiteSources(sources) {
    if (sources.length === 0) return 0;
    
    // 1. Moyenne de fiabilit√©
    const fiabiliteMoyenne = sources.reduce((sum, s) => sum + s.fiabilite, 0) / sources.length;
    
    // 2. Nombre de sources (bonus si > minimum)
    const scoreNombre = Math.min(sources.length / CONFIG.MIN_SOURCES, 1.5);
    
    // 3. Richesse du contenu
    let totalExtraits = 0;
    let totalDonnees = 0;
    sources.forEach(s => {
      totalExtraits += (s.extraits || []).length;
      totalDonnees += (s.donnees || []).length;
    });
    const richesseMoyenne = (totalExtraits + totalDonnees) / sources.length;
    const scoreRichesse = Math.min(richesseMoyenne / 5, 1);
    
    // 4. Diversit√© des types
    const types = new Set(sources.map(s => s.type || 'Article'));
    const scoreDiversite = types.size >= 2 ? 1 : 0.7;
    
    // Calcul final
    const scoreFinal = (
      (fiabiliteMoyenne / 10) * 0.3 +
      scoreNombre * 0.2 +
      scoreRichesse * 0.3 +
      scoreDiversite * 0.2
    );
    
    return scoreFinal;
  }

  async sauvegarderVeille(contenu, sujets) {
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    const outputPath = await DateHelper.getPathForType('./output', 'veille', date);
    
    // Nom du fichier selon le mode
    const prefix = this.mode === 'DIRIGE' ? 'veille-dirigee' : 'veille';
    const filename = `${prefix}-${dateStr}.md`;
    const filepath = path.join(outputPath, filename);
    
    // Ajouter l'en-t√™te
    let contenuFinal = `# üìä VEILLE PRIZM AI v5 - ${date.toLocaleDateString('fr-FR', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    })}\n\n`;
    
    contenuFinal += `*Mode : ${this.mode} - Collecte multi-sources et corpus v√©rifi√©*\n\n`;
    
    if (this.mode === 'DIRIGE' && this.sujetImpose) {
      contenuFinal += `## üéØ Sujet impos√©\n`;
      contenuFinal += `**Titre** : ${this.sujetImpose.titre}\n`;
      contenuFinal += `**Cat√©gorie** : ${this.sujetImpose.category || 'actualites'}\n`;
      contenuFinal += `**Angle** : ${this.sujetImpose.angle || 'Non sp√©cifi√©'}\n\n`;
    }
    
    contenuFinal += `---\n\n`;
    contenuFinal += `## üéØ Synth√®se ex√©cutive\n\n`;
    contenuFinal += `${sujets.length} sujet(s) analys√©(s) avec ${sujets.reduce((acc, s) => acc + s.sources.length, 0)} sources v√©rifi√©es.\n`;
    contenuFinal += `Score de qualit√© moyen : ${(sujets.reduce((acc, s) => acc + s.scoreQualite, 0) / sujets.length).toFixed(2)}/1\n\n`;
    contenuFinal += `---\n\n`;
    
    contenuFinal += contenu;
    
    await fs.writeFile(filepath, contenuFinal, 'utf-8');
    console.log(`\nüíæ Veille sauvegard√©e : ${filepath}`);
    
    this.resultats = {
      fichierVeille: filepath,
      date: dateStr,
      sujets: sujets.length,
      mode: this.mode
    };
  }

  async creerCorpusVerifie(sujet) {
    console.log(`\nüìö Cr√©ation du corpus pour : ${sujet.titre}`);
    
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0];
    
    // Cr√©er un slug propre pour le dossier
    const titreSanitize = sujet.titre
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Enlever les accents
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 60);
    
    const corpusDir = path.join(
      CONFIG.CORPUS_DIR,
      dateStr,
      `${sujet.numero}-${titreSanitize}`
    );
    
    await fs.mkdir(corpusDir, { recursive: true });
    
    // Sauvegarder les m√©tadonn√©es
    const metadata = {
      titre: sujet.titre,
      dateCreation: sujet.timestamp,
      scoreQualite: sujet.scoreQualite,
      modeGeneration: sujet.modeGeneration || 'AUTO',
      category: sujet.category || 'actualites',
      sources: sujet.sources.map(s => ({
        nom: s.nom,
        type: s.type,
        url: s.url,
        date: s.date,
        fiabilite: s.fiabilite,
        extraits: s.extraits || []
      })),
      synthese: sujet.synthese
    };
    
    await fs.writeFile(
      path.join(corpusDir, 'metadata.json'),
      JSON.stringify(metadata, null, 2)
    );
    
    // Sauvegarder chaque source
    for (let i = 0; i < sujet.sources.length; i++) {
      const source = sujet.sources[i];
      let contenuSource = `# ${source.nom}\n\n`;
      contenuSource += `**Type** : ${source.type}\n`;
      contenuSource += `**URL** : ${source.url}\n`;
      contenuSource += `**Date** : ${source.date}\n`;
      contenuSource += `**Fiabilit√©** : ${source.fiabilite}/10\n\n`;
      
      if (source.extraits && source.extraits.length > 0) {
        contenuSource += `## Citations\n\n`;
        source.extraits.forEach(e => {
          contenuSource += `* "${e}"\n`;
        });
      }
      
      if (source.donnees && source.donnees.length > 0) {
        contenuSource += `\n## Donn√©es factuelles\n\n`;
        source.donnees.forEach(d => {
          contenuSource += `- ${d}\n`;
        });
      }
      
      const nomFichier = source.nom.toLowerCase().replace(/[^a-z0-9]+/g, '-');
      await fs.writeFile(
        path.join(corpusDir, `source-${i + 1}-${nomFichier}.md`),
        contenuSource
      );
    }
    
    console.log(`   ‚úÖ Corpus cr√©√© : ${corpusDir}`);
    
    return corpusDir;
  }
}

// Script principal
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
üìö Agent Veille v5 - Mode Hybride
==================================

Collecte et v√©rifie des sources avec deux modes de fonctionnement.

Usage :
  node agent-veille-v5.cjs [options]                    # Mode AUTO
  node agent-veille-v5.cjs --dirige "titre" [options]   # Mode DIRIG√â

Options :
  --auto       Mode automatique (d√©faut) : Perplexity choisit les sujets
  --dirige     Mode dirig√© : impose un sujet sp√©cifique
  --titre      Titre du sujet (obligatoire avec --dirige)
  --angle      Angle √©ditorial (optionnel)
  --keywords   Mots-cl√©s pour la recherche (optionnel)
  --category   Cat√©gorie : actualites|guides|analyses (d√©faut: actualites)
  --complet    Recherche approfondie multi-domaines (mode AUTO)
  --help, -h   Affiche cette aide

Exemples :
  # Mode AUTO (comportement v4)
  node agent-veille-v5.cjs
  node agent-veille-v5.cjs --auto --complet
  
  # Mode DIRIG√â (nouveau)
  node agent-veille-v5.cjs --dirige --titre "IA g√©n√©rative pour PME en 2025"
  node agent-veille-v5.cjs --dirige \\
    --titre "Microsoft Copilot vs ChatGPT Enterprise" \\
    --angle "Comparatif pour PME fran√ßaises" \\
    --keywords "Copilot, ChatGPT, comparatif, prix, fonctionnalit√©s" \\
    --category "analyses"

Fonctionnement :
  Mode AUTO :
    1. Recherche 5 sujets d'actualit√© IA via Perplexity
    2. Collecte 3-5 sources par sujet
    3. V√©rifie la qualit√© et filtre
    4. Cr√©e les corpus pour les sujets retenus
    
  Mode DIRIG√â :
    1. Recherche approfondie sur LE sujet impos√©
    2. Collecte 4-5 sources sp√©cifiques
    3. Cr√©e un corpus d√©taill√©
    4. Pr√©pare pour la r√©daction
    `);
    process.exit(0);
  }
  
  const agent = new AgentVeilleV5();
  
  try {
    let options = {
      mode: 'AUTO',
      complet: args.includes('--complet')
    };
    
    // D√©terminer le mode
    if (args.includes('--dirige')) {
      options.mode = 'DIRIGE';
      
      // Extraire les param√®tres du sujet
      const titreIndex = args.findIndex(a => a === '--titre');
      if (titreIndex === -1 || !args[titreIndex + 1]) {
        console.error('‚ùå Le mode DIRIG√â n√©cessite un titre (--titre "...")');
        process.exit(1);
      }
      
      options.sujet = {
        titre: args[titreIndex + 1]
      };
      
      // Param√®tres optionnels
      const angleIndex = args.findIndex(a => a === '--angle');
      if (angleIndex !== -1 && args[angleIndex + 1]) {
        options.sujet.angle = args[angleIndex + 1];
      }
      
      const keywordsIndex = args.findIndex(a => a === '--keywords');
      if (keywordsIndex !== -1 && args[keywordsIndex + 1]) {
        options.sujet.keywords = args[keywordsIndex + 1];
      }
      
      const categoryIndex = args.findIndex(a => a === '--category');
      if (categoryIndex !== -1 && args[categoryIndex + 1]) {
        options.sujet.category = args[categoryIndex + 1];
      }
    }
    
    console.time('‚è±Ô∏è Dur√©e totale');
    const resultat = await agent.executer(options);
    console.timeEnd('‚è±Ô∏è Dur√©e totale');
    
    console.log('\n‚ú® Veille termin√©e avec succ√®s !');
    if (resultat.mode === 'DIRIGE') {
      console.log(`\nüìÑ Article √† g√©n√©rer : ${resultat.sujets[0].titre}`);
      console.log(`üìö Corpus pr√™t : ${resultat.sujets[0].corpusPath}`);
    }
    
  } catch (error) {
    console.error('\n‚ùå Erreur :', error.message);
    process.exit(1);
  }
}

// Export pour utilisation dans le pipeline
module.exports = AgentVeilleV5;

// Lancer si ex√©cut√© directement
if (require.main === module) {
  main();
}