// pipeline-v5-batch.cjs - Pipeline batch utilisant l'agent-veille-v5 en mode dirigÃ©
require('dotenv').config({ path: '../config/.env' });
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

// Configuration
const CONFIG = {
  AGENTS: {
    veille: './agent-veille-v5.cjs', // Nouvelle version
    redacteurFactuel: './agent-redacteur-factuel.cjs',
    styleConversationnel: './agent-style-conversationnel.cjs'
  },
  STRUCTURE: {
    base: './output',
    veille: '01-veille',
    corpus: '02-corpus',
    factuels: '03-articles-factuels',
    conversationnels: '04-articles-conversationnels',
    finaux: '05-articles-finaux',
    rapports: '06-rapports',
    archives: '07-archives'
  },
  VALIDATION: {
    longueurMin: 1400,
    longueurMax: 1800,
    longueurCible: 1500
  },
  BATCH: {
    pauseEntreSujets: 20000, // 20 secondes entre chaque article
    pauseCourtePourAPI: 5000, // 5 secondes pour Ã©viter rate limiting
    maxRetries: 2
  }
};

// LISTE DES SUJETS Ã€ TRAITER
const SUJETS_BATCH = [
  // ActualitÃ©s (4 articles)
  {
    titre: "IA gÃ©nÃ©rative 2025 : les outils indispensables pour les PME franÃ§aises",
    category: "actualites",
    angle: "PrÃ©sentation des nouveaux outils avec ROI prouvÃ© et cas d'usage concrets",
    keywords: "ChatGPT Enterprise, Claude, Microsoft Copilot, Mistral, productivitÃ©, PME, France"
  },
  {
    titre: "RÃ©glementation IA europÃ©enne : guide de conformitÃ© pratique pour PME",
    category: "actualites",
    angle: "DÃ©cryptage de l'AI Act avec check-list de mise en conformitÃ©",
    keywords: "AI Act, RGPD, conformitÃ©, rÃ©glementation, Ã©thique IA, Europe, PME"
  },
  {
    titre: "Microsoft Copilot vs ChatGPT Enterprise : comparatif dÃ©taillÃ© pour PME",
    category: "actualites",
    angle: "Analyse comparative avec prix, fonctionnalitÃ©s et recommandations",
    keywords: "Copilot, ChatGPT, comparatif, assistant IA, productivitÃ©, entreprise"
  },
  {
    titre: "L'IA dans la comptabilitÃ© : automatisation et gains de productivitÃ© mesurÃ©s",
    category: "actualites",
    angle: "Solutions concrÃ¨tes pour automatiser saisie, facturation et reporting",
    keywords: "comptabilitÃ©, automatisation, Pennylane, Dext, gains productivitÃ©, PME"
  },
  
  // Guides Pratiques (4 articles)
  {
    titre: "ImplÃ©menter ChatGPT dans votre service client : guide complet Ã©tape par Ã©tape",
    category: "guides",
    angle: "Tutoriel dÃ©taillÃ© avec paramÃ©trage, formation Ã©quipes et mesure ROI",
    keywords: "service client, chatbot, ChatGPT, implementation, ROI, support"
  },
  {
    titre: "Automatiser sa prospection commerciale avec l'IA : mÃ©thode en 5 Ã©tapes",
    category: "guides",
    angle: "Process pour identifier, qualifier et contacter automatiquement les prospects",
    keywords: "prospection, commercial, automatisation, CRM, leads, Sales"
  },
  {
    titre: "CrÃ©er du contenu marketing avec l'IA : workflow complet et outils testÃ©s",
    category: "guides",
    angle: "MÃ©thodologie pour gÃ©nÃ©rer articles, posts sociaux et newsletters",
    keywords: "content marketing, rÃ©daction, IA gÃ©nÃ©rative, workflow, crÃ©ation contenu"
  },
  {
    titre: "Calculer le ROI de l'IA dans votre PME : mÃ©thode et exemples chiffrÃ©s",
    category: "guides",
    angle: "Framework de calcul avec cas pratiques et template Excel",
    keywords: "ROI, rentabilitÃ©, investissement, mÃ©triques, calcul, KPI"
  },
  
  // Analyses (2 articles)
  {
    titre: "Adoption de l'IA dans les PME franÃ§aises 2025 : chiffres et tendances",
    category: "analyses",
    angle: "Ã‰tat des lieux chiffrÃ© avec freins, opportunitÃ©s et projections",
    keywords: "statistiques, adoption IA, PME, France, tendances, Ã©tude marchÃ©"
  },
  {
    titre: "IA et cybersÃ©curitÃ© : nouveaux risques et solutions pour les PME",
    category: "analyses",
    angle: "Analyse des menaces et guide de protection des donnÃ©es",
    keywords: "cybersÃ©curitÃ©, risques IA, protection donnÃ©es, RGPD, sÃ©curitÃ©"
  }
];

class PipelineV5Batch {
  constructor() {
    this.sessionId = this.genererSessionId();
    this.resultats = {
      total: SUJETS_BATCH.length,
      reussis: 0,
      echecs: 0,
      articles: [],
      erreurs: []
    };
    this.startTime = Date.now();
  }

  genererSessionId() {
    const date = new Date();
    return `batch-v5-${date.toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '-')}`;
  }

  async initialiser() {
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          PIPELINE V5 BATCH - PRIZM AI                  â•‘
â•‘      GÃ©nÃ©ration dirigÃ©e de ${String(SUJETS_BATCH.length).padEnd(2)} articles               â•‘
â•‘                                                        â•‘
â•‘  Session : ${this.sessionId}            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);

    // CrÃ©er la structure
    await this.creerStructure();
    
    // VÃ©rifier les agents
    await this.verifierAgents();
    
    // Archiver les anciennes veilles pour Ã©viter les conflits
    await this.archiverAnciennesVeilles();
    
    console.log('\nâœ… Pipeline batch v5 initialisÃ©');
    console.log('ğŸ¯ Mode : DIRIGÃ‰ (sujets imposÃ©s)\n');
    console.log(`ğŸ“‹ Articles Ã  gÃ©nÃ©rer :`);
    SUJETS_BATCH.forEach((s, i) => {
      console.log(`   ${i + 1}. [${s.category}] ${s.titre}`);
    });
    console.log('\n' + 'â•'.repeat(60) + '\n');
    
    return true;
  }

  async creerStructure() {
    for (const [key, dossier] of Object.entries(CONFIG.STRUCTURE)) {
      if (key !== 'base') {
        const chemin = path.join(CONFIG.STRUCTURE.base, dossier);
        await fs.mkdir(chemin, { recursive: true });
      }
    }
  }

  async verifierAgents() {
    console.log('ğŸ” VÃ©rification des agents...');
    for (const [nom, fichier] of Object.entries(CONFIG.AGENTS)) {
      try {
        await fs.access(fichier);
        console.log(`   âœ“ ${nom} (${fichier})`);
      } catch {
        throw new Error(`Agent ${nom} introuvable : ${fichier}`);
      }
    }
  }

  async archiverAnciennesVeilles() {
    try {
      const veilleDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.veille);
      const archiveDir = path.join(
        CONFIG.STRUCTURE.base, 
        CONFIG.STRUCTURE.archives, 
        'veilles-avant-batch-v5',
        this.sessionId
      );
      
      await fs.mkdir(archiveDir, { recursive: true });
      
      // Fonction rÃ©cursive pour archiver
      async function archiverRecursif(source, dest) {
        const entrees = await fs.readdir(source, { withFileTypes: true });
        
        for (const entree of entrees) {
          const sourcePath = path.join(source, entree.name);
          const destPath = path.join(dest, entree.name);
          
          if (entree.isDirectory()) {
            await fs.mkdir(destPath, { recursive: true });
            await archiverRecursif(sourcePath, destPath);
          } else if (entree.isFile() && entree.name.endsWith('.md')) {
            await fs.rename(sourcePath, destPath);
          }
        }
      }
      
      const files = await fs.readdir(veilleDir);
      if (files.length > 0) {
        await archiverRecursif(veilleDir, archiveDir);
        console.log(`   ğŸ“¦ Anciennes veilles archivÃ©es dans : ${archiveDir}`);
      }
    } catch (e) {
      // Pas grave si le dossier est vide
    }
  }

  /**
   * GÃ©nÃ©rer un article pour un sujet imposÃ©
   */
  async genererArticlePourSujet(sujet, numero) {
    console.log(`\n${'â”€'.repeat(60)}`);
    console.log(`[${numero}/${SUJETS_BATCH.length}] ${sujet.titre}`);
    console.log(`   ğŸ“‚ CatÃ©gorie : ${sujet.category}`);
    console.log(`   ğŸ¯ Angle : ${sujet.angle.substring(0, 60)}...`);
    
    try {
      // Ã‰tape 1 : Lancer l'agent-veille-v5 en mode DIRIGÃ‰
      console.log(`\n   ğŸ“° Lancement de la veille dirigÃ©e...`);
      const debutVeille = Date.now();
      
      // Construire la commande avec tous les paramÃ¨tres
      const commande = [
        `node ${CONFIG.AGENTS.veille}`,
        '--dirige',
        `--titre "${sujet.titre}"`,
        `--angle "${sujet.angle}"`,
        `--keywords "${sujet.keywords}"`,
        `--category "${sujet.category}"`
      ].join(' ');
      
      try {
        const { stdout, stderr } = await execPromise(commande);
        
        if (stderr && !stderr.includes('Warning')) {
          console.log('   âš ï¸ Avertissements :', stderr.substring(0, 100));
        }
        
        // Attendre que le corpus soit crÃ©Ã©
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        console.log(`   âœ… Veille et corpus crÃ©Ã©s en ${Math.round((Date.now() - debutVeille) / 1000)}s`);
        
      } catch (error) {
        throw new Error(`Erreur veille dirigÃ©e : ${error.message}`);
      }
      
      // Ã‰tape 2 : Trouver le corpus crÃ©Ã©
      const corpusPath = await this.trouverDernierCorpus(sujet.titre);
      
      if (!corpusPath) {
        throw new Error('Corpus non trouvÃ© aprÃ¨s la veille');
      }
      
      console.log(`   ğŸ“š Corpus trouvÃ© : ${path.basename(corpusPath)}`);
      
      // Ã‰tape 3 : Lancer la rÃ©daction factuelle
      console.log(`   âœï¸ GÃ©nÃ©ration de l'article factuel...`);
      const debutRedaction = Date.now();
      
      const commandeRedaction = `node ${CONFIG.AGENTS.redacteurFactuel} "${corpusPath}"`;
      
      try {
        await execPromise(commandeRedaction);
        console.log(`   âœ… Article factuel gÃ©nÃ©rÃ© en ${Math.round((Date.now() - debutRedaction) / 1000)}s`);
      } catch (error) {
        throw new Error(`Erreur rÃ©daction : ${error.message}`);
      }
      
      // Ã‰tape 4 : Appliquer le style conversationnel (optionnel)
      const articleFactuel = await this.trouverDernierArticleFactuel();
      
      if (articleFactuel) {
        console.log(`   ğŸ—£ï¸ Application du style conversationnel...`);
        try {
          await execPromise(`node ${CONFIG.AGENTS.styleConversationnel} "${articleFactuel}"`);
          console.log(`   âœ… Style conversationnel appliquÃ©`);
        } catch (error) {
          console.log(`   âš ï¸ Style conversationnel Ã©chouÃ© (non bloquant)`);
        }
      }
      
      // Ã‰tape 5 : RÃ©cupÃ©rer et formater l'article final
      const articleFinal = await this.recupererEtFormaterArticle(sujet, numero);
      
      if (articleFinal) {
        this.resultats.articles.push({
          sujet: sujet.titre,
          category: sujet.category,
          fichier: articleFinal.fichier,
          chemin: articleFinal.chemin,
          duree: Math.round((Date.now() - debutVeille) / 1000)
        });
        this.resultats.reussis++;
        
        console.log(`   âœ… Article complÃ©tÃ© en ${Math.round((Date.now() - debutVeille) / 1000)}s total`);
      }
      
      return true;
      
    } catch (error) {
      console.log(`   âŒ Ã‰chec : ${error.message}`);
      this.resultats.echecs++;
      this.resultats.erreurs.push({
        sujet: sujet.titre,
        erreur: error.message
      });
      return false;
    }
  }

  /**
   * Trouver le corpus crÃ©Ã© pour un sujet
   */
  async trouverDernierCorpus(titreSujet) {
    const date = new Date().toISOString().split('T')[0];
    const corpusDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.corpus, date);
    
    try {
      const dossiers = await fs.readdir(corpusDir);
      
      // CrÃ©er un slug du titre pour la recherche
      const titreSanitize = titreSujet.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .substring(0, 50);
      
      // Chercher un dossier qui correspond
      const dossierTrouve = dossiers.find(d => {
        const dLower = d.toLowerCase();
        // Chercher par mots clÃ©s du titre
        const motsCles = titreSanitize.split('-').filter(m => m.length > 3);
        return motsCles.some(mot => dLower.includes(mot));
      });
      
      if (dossierTrouve) {
        return path.join(corpusDir, dossierTrouve);
      }
      
      // Si pas trouvÃ©, prendre le plus rÃ©cent
      if (dossiers.length > 0) {
        const dernierDossier = dossiers.sort().pop();
        return path.join(corpusDir, dernierDossier);
      }
      
    } catch (error) {
      console.log('   âš ï¸ Erreur recherche corpus :', error.message);
    }
    
    return null;
  }

  /**
   * Trouver le dernier article factuel gÃ©nÃ©rÃ©
   */
  async trouverDernierArticleFactuel() {
    const factuelDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.factuels);
    
    try {
      const fichiers = await fs.readdir(factuelDir);
      const articles = fichiers.filter(f => f.endsWith('.md'));
      
      if (articles.length > 0) {
        const dernier = articles.sort().pop();
        return path.join(factuelDir, dernier);
      }
    } catch (error) {
      console.log('   âš ï¸ Article factuel non trouvÃ©');
    }
    
    return null;
  }

  /**
   * RÃ©cupÃ©rer et formater l'article final
   */
  async recupererEtFormaterArticle(sujet, numero) {
    try {
      // Chercher dans les articles finaux
      const finauxDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.finaux);
      const fichiers = await fs.readdir(finauxDir);
      
      const articles = fichiers.filter(f => f.endsWith('.md'));
      if (articles.length === 0) return null;
      
      // Prendre le plus rÃ©cent
      const dernierArticle = articles.sort().pop();
      const cheminArticle = path.join(finauxDir, dernierArticle);
      
      // Lire le contenu
      let contenu = await fs.readFile(cheminArticle, 'utf-8');
      
      // Corriger l'encodage
      contenu = this.corrigerEncodage(contenu);
      
      // Ajouter/corriger le frontmatter
      contenu = this.ajouterFrontmatter(contenu, sujet);
      
      // CrÃ©er le nom final
      const date = new Date().toISOString().split('T')[0];
      const slug = sujet.titre.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .substring(0, 60);
      
      const nomFinal = `${date}-${String(numero).padStart(2, '0')}-${slug}.md`;
      
      // Sauvegarder dans le dossier de staging
      const stagingDir = path.join(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready');
      await fs.mkdir(stagingDir, { recursive: true });
      
      const cheminFinal = path.join(stagingDir, nomFinal);
      await fs.writeFile(cheminFinal, contenu, 'utf-8');
      
      console.log(`   ğŸ“„ Article formatÃ© : ${nomFinal}`);
      
      return {
        fichier: nomFinal,
        chemin: cheminFinal
      };
      
    } catch (error) {
      console.log('   âš ï¸ Erreur formatage article :', error.message);
      return null;
    }
  }

  corrigerEncodage(texte) {
    const replacements = {
      'Ã©': 'Ã©', 'Ã¨': 'Ã¨', 'Ã ': 'Ã ', 'Ã¢': 'Ã¢', 'Ãª': 'Ãª',
      'Ã´': 'Ã´', 'Ã¹': 'Ã¹', 'Ã»': 'Ã»', 'Ã§': 'Ã§', 'Ã®': 'Ã®',
      'Ã¯': 'Ã¯', 'Ã…"': 'Å“', 'Ã‰': 'Ã‰', 'Ãˆ': 'Ãˆ', 'Ã€': 'Ã€',
      'Ã¢â‚¬â„¢': "'", 'Ã¢â‚¬Å“': '"', 'Ã¢â‚¬': '"', 'Ã¢â‚¬Â¦': '...',
      'Ã¢â‚¬"': 'â€”', 'Ã¢â‚¬"': 'â€“', 'Ã¢â€Â¢': 'â„¢', 'Ã‚Â©': 'Â©'
    };
    
    let fixed = texte;
    for (const [bad, good] of Object.entries(replacements)) {
      fixed = fixed.replace(new RegExp(bad, 'g'), good);
    }
    return fixed;
  }

  ajouterFrontmatter(contenu, sujet) {
    // Supprimer l'ancien frontmatter s'il existe
    contenu = contenu.replace(/^---[\s\S]*?---\n*/m, '');
    
    // Extraire le titre du contenu
    const titleMatch = contenu.match(/^#\s+(.+)$/m);
    const title = titleMatch ? titleMatch[1] : sujet.titre;
    
    // Calculer le temps de lecture
    const wordCount = contenu.split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 250);
    
    // GÃ©nÃ©rer la description
    const description = sujet.angle.substring(0, 150) + '...';
    
    // DÃ©terminer l'emoji selon la catÃ©gorie
    const emojis = {
      'actualites': 'ğŸš€',
      'guides': 'ğŸ“š',
      'analyses': 'ğŸ“Š'
    };
    
    const date = new Date().toISOString().split('T')[0];
    
    // CrÃ©er le frontmatter
    const frontmatter = `---
title: "${title}"
description: "${description}"
pubDate: ${date}
author: "L'Ã©quipe Prizm AI"
emoji: "${emojis[sujet.category] || 'ğŸ’¡'}"
category: "${sujet.category}"
featured: ${this.resultats.reussis < 3 ? 'true' : 'false'}
readingTime: "${readingTime} min"
---

`;
    
    return frontmatter + contenu;
  }

  /**
   * ExÃ©cuter le batch complet
   */
  async executer() {
    try {
      await this.initialiser();
      
      // Traiter chaque sujet
      for (let i = 0; i < SUJETS_BATCH.length; i++) {
        const sujet = SUJETS_BATCH[i];
        const numero = i + 1;
        
        // GÃ©nÃ©rer l'article
        await this.genererArticlePourSujet(sujet, numero);
        
        // Pause entre les articles (sauf pour le dernier)
        if (i < SUJETS_BATCH.length - 1) {
          const pauseSeconds = CONFIG.BATCH.pauseEntreSujets / 1000;
          console.log(`\n   â¸ï¸ Pause de ${pauseSeconds}s avant le prochain article...`);
          await new Promise(resolve => setTimeout(resolve, CONFIG.BATCH.pauseEntreSujets));
        }
      }
      
      // Rapport final
      await this.genererRapport();
      
      return this.resultats;
      
    } catch (error) {
      console.error('\nâŒ ERREUR PIPELINE BATCH :', error.message);
      throw error;
    }
  }

  /**
   * GÃ©nÃ©rer le rapport final et le script de publication
   */
  async genererRapport() {
    const dureeTotal = Math.round((Date.now() - this.startTime) / 1000 / 60);
    
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              BATCH V5 TERMINÃ‰                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š RÃ‰SUMÃ‰ DE LA SESSION ${this.sessionId}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â±ï¸ DurÃ©e totale : ${dureeTotal} minutes
âœ… Articles rÃ©ussis : ${this.resultats.reussis}/${this.resultats.total}
âŒ Ã‰checs : ${this.resultats.echecs}
`);

    if (this.resultats.reussis > 0) {
      console.log('\nğŸ“„ ARTICLES GÃ‰NÃ‰RÃ‰S :');
      
      // Grouper par catÃ©gorie
      const parCategorie = {};
      this.resultats.articles.forEach(article => {
        if (!parCategorie[article.category]) {
          parCategorie[article.category] = [];
        }
        parCategorie[article.category].push(article);
      });
      
      for (const [category, articles] of Object.entries(parCategorie)) {
        console.log(`\n   ${category.toUpperCase()} (${articles.length}) :`);
        articles.forEach((article, i) => {
          console.log(`   ${i + 1}. ${article.sujet}`);
          console.log(`      ğŸ“ ${article.fichier}`);
          console.log(`      â±ï¸ ${article.duree}s`);
        });
      }
    }

    if (this.resultats.echecs > 0) {
      console.log('\nâš ï¸ ERREURS RENCONTRÃ‰ES :');
      this.resultats.erreurs.forEach(err => {
        console.log(`   - ${err.sujet}`);
        console.log(`     ${err.erreur}`);
      });
    }

    // Sauvegarder le rapport JSON
    const rapportPath = path.join(
      CONFIG.STRUCTURE.base,
      CONFIG.STRUCTURE.rapports,
      `rapport-${this.sessionId}.json`
    );
    
    await fs.writeFile(
      rapportPath,
      JSON.stringify(this.resultats, null, 2),
      'utf-8'
    );
    
    // CrÃ©er un script PowerShell pour publier
    const scriptPublish = `
# Script de publication des articles gÃ©nÃ©rÃ©s - Pipeline V5
# Session : ${this.sessionId}
# Date : ${new Date().toLocaleString('fr-FR')}

$source = "${path.resolve(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready')}"
$dest = "C:\\Users\\Samuel\\Documents\\prizmia\\src\\content\\blog"

Write-Host ""
Write-Host "ğŸ“š PUBLICATION DES ARTICLES BATCH V5" -ForegroundColor Cyan
Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Cyan
Write-Host ""
Write-Host "Source : $source" -ForegroundColor Gray
Write-Host "Destination : $dest" -ForegroundColor Gray
Write-Host ""

$files = Get-ChildItem -Path $source -Filter "*.md"
$count = $files.Count

Write-Host "ğŸ“Š $count articles Ã  copier" -ForegroundColor Yellow
Write-Host ""

$copied = 0
foreach ($file in $files) {
    try {
        Copy-Item $file.FullName -Destination $dest -Force
        $copied++
        Write-Host "  âœ… $($file.Name)" -ForegroundColor Green
    } catch {
        Write-Host "  âŒ Erreur avec $($file.Name): $_" -ForegroundColor Red
    }
}

Write-Host ""
Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Cyan
Write-Host "âœ¨ TerminÃ© ! $copied/$count articles copiÃ©s." -ForegroundColor Green
Write-Host ""
Write-Host "Prochaines Ã©tapes :" -ForegroundColor Yellow
Write-Host "  1. cd C:\\Users\\Samuel\\Documents\\prizmia" -ForegroundColor White
Write-Host "  2. npm run dev  # Pour tester localement" -ForegroundColor White
Write-Host "  3. git add ." -ForegroundColor White
Write-Host "  4. git commit -m 'Ajout de $copied articles - Batch V5'" -ForegroundColor White
Write-Host "  5. git push" -ForegroundColor White
Write-Host ""
`;

    const scriptPath = path.join(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready', 'publish-to-blog.ps1');
    await fs.writeFile(scriptPath, scriptPublish, 'utf-8');
    
    console.log(`
ğŸ“‹ PROCHAINES Ã‰TAPES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. VÃ©rifier les articles :
   cd output/articles-batch-v5-ready
   dir *.md
   
2. Publier avec PowerShell :
   .\\publish-to-blog.ps1
   
3. Tester localement :
   cd C:\\Users\\Samuel\\Documents\\prizmia
   npm run dev
   # Ouvrir http://localhost:4321
   
4. DÃ©ployer :
   git add .
   git commit -m "Ajout de ${this.resultats.reussis} articles - Pipeline V5 Batch"
   git push

ğŸ’¾ Rapport sauvegardÃ© : ${rapportPath}
ğŸ“œ Script de publication : publish-to-blog.ps1

âœ¨ Pipeline V5 Batch terminÃ© avec succÃ¨s !
`);
  }
}

// === POINT D'ENTRÃ‰E ===
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
ğŸš€ Pipeline V5 Batch - Prizm AI
================================

GÃ©nÃ¨re des articles en mode DIRIGÃ‰ avec trois options possibles.

Usage :
  node pipeline-v5-batch.cjs [options]              # Sujets prÃ©dÃ©finis
  node pipeline-v5-batch.cjs --single [params]      # Un seul sujet
  node pipeline-v5-batch.cjs --file <fichier.json>  # Liste depuis fichier

Options gÃ©nÃ©rales :
  --test       Mode test (gÃ©nÃ¨re seulement 2 articles)
  --rapide     Pauses rÃ©duites (10s au lieu de 20s)
  --help, -h   Affiche cette aide

Mode SINGLE (un seul sujet) :
  --single     Active le mode sujet unique
  --titre      Titre du sujet (obligatoire)
  --category   actualites|guides|analyses (dÃ©faut: actualites)
  --angle      Angle Ã©ditorial (optionnel)
  --keywords   Mots-clÃ©s sÃ©parÃ©s par virgules (optionnel)

Mode FILE (liste depuis fichier) :
  --file       Chemin vers un fichier JSON contenant les sujets

Exemples :
  # Utiliser les 10 sujets prÃ©dÃ©finis
  node pipeline-v5-batch.cjs
  
  # GÃ©nÃ©rer un seul article sur un sujet spÃ©cifique
  node pipeline-v5-batch.cjs --single \\
    --titre "L'IA dans le e-commerce en 2025" \\
    --category "guides" \\
    --angle "Solutions pratiques pour boutiques en ligne"
  
  # Utiliser une liste personnalisÃ©e
  node pipeline-v5-batch.cjs --file mes-sujets.json
  
  # Mode test avec sujets prÃ©dÃ©finis
  node pipeline-v5-batch.cjs --test

Format du fichier JSON :
[
  {
    "titre": "Titre du sujet",
    "category": "actualites",
    "angle": "Angle Ã©ditorial",
    "keywords": "mot1, mot2, mot3"
  },
  ...
]

DurÃ©e estimÃ©e : 
  - Un sujet : ~2-3 minutes
  - 10 sujets : ~30-40 minutes
    `);
    process.exit(0);
  }
  
  const pipeline = new PipelineV5Batch();
  
  try {
    let sujetsATraiter = SUJETS_BATCH;
    
    // Mode SINGLE : un seul sujet depuis la ligne de commande
    if (args.includes('--single')) {
      const titreIndex = args.findIndex(a => a === '--titre');
      if (titreIndex === -1 || !args[titreIndex + 1]) {
        console.error('âŒ Le mode --single nÃ©cessite un --titre');
        process.exit(1);
      }
      
      const sujetUnique = {
        titre: args[titreIndex + 1],
        category: 'actualites',
        angle: 'Analyse pratique pour PME/ETI',
        keywords: 'PME, ETI, France, transformation digitale'
      };
      
      // ParamÃ¨tres optionnels
      const categoryIndex = args.findIndex(a => a === '--category');
      if (categoryIndex !== -1 && args[categoryIndex + 1]) {
        sujetUnique.category = args[categoryIndex + 1];
      }
      
      const angleIndex = args.findIndex(a => a === '--angle');
      if (angleIndex !== -1 && args[angleIndex + 1]) {
        sujetUnique.angle = args[angleIndex + 1];
      }
      
      const keywordsIndex = args.findIndex(a => a === '--keywords');
      if (keywordsIndex !== -1 && args[keywordsIndex + 1]) {
        sujetUnique.keywords = args[keywordsIndex + 1];
      }
      
      sujetsATraiter = [sujetUnique];
      console.log('\nğŸ“ MODE SINGLE : Un seul article');
      console.log(`   Sujet : ${sujetUnique.titre}`);
      console.log(`   CatÃ©gorie : ${sujetUnique.category}\n`);
    }
    
    // Mode FILE : charger depuis un fichier JSON
    else if (args.includes('--file')) {
      const fileIndex = args.findIndex(a => a === '--file');
      if (fileIndex === -1 || !args[fileIndex + 1]) {
        console.error('âŒ Le mode --file nÃ©cessite un nom de fichier');
        process.exit(1);
      }
      
      const filepath = args[fileIndex + 1];
      try {
        const fileContent = await fs.readFile(filepath, 'utf-8');
        sujetsATraiter = JSON.parse(fileContent);
        
        // Validation basique
        if (!Array.isArray(sujetsATraiter) || sujetsATraiter.length === 0) {
          throw new Error('Le fichier doit contenir un tableau de sujets');
        }
        
        // VÃ©rifier que chaque sujet a au moins un titre
        sujetsATraiter.forEach((s, i) => {
          if (!s.titre) {
            throw new Error(`Le sujet ${i + 1} n'a pas de titre`);
          }
          // Ajouter les valeurs par dÃ©faut si manquantes
          s.category = s.category || 'actualites';
          s.angle = s.angle || 'Analyse pratique pour PME/ETI';
          s.keywords = s.keywords || 'PME, ETI, France';
        });
        
        console.log(`\nğŸ“„ MODE FILE : ${sujetsATraiter.length} sujets chargÃ©s depuis ${filepath}\n`);
        
      } catch (error) {
        console.error(`âŒ Erreur lecture fichier : ${error.message}`);
        process.exit(1);
      }
    }
    
    // Mode test : limiter le nombre de sujets
    if (args.includes('--test')) {
      const nbTest = Math.min(2, sujetsATraiter.length);
      sujetsATraiter = sujetsATraiter.slice(0, nbTest);
      console.log(`\nâš ï¸ MODE TEST : ${nbTest} articles seulement\n`);
    }
    
    // Mode rapide : pauses rÃ©duites
    if (args.includes('--rapide')) {
      CONFIG.BATCH.pauseEntreSujets = 10000;
      console.log('\nâš¡ MODE RAPIDE : Pauses rÃ©duites\n');
    }
    
    // Remplacer SUJETS_BATCH par les sujets Ã  traiter
    SUJETS_BATCH.length = 0;
    SUJETS_BATCH.push(...sujetsATraiter);
    
    console.time('â±ï¸ DurÃ©e totale du batch');
    await pipeline.executer();
    console.timeEnd('â±ï¸ DurÃ©e totale du batch');
    
    process.exit(0);
    
  } catch (error) {
    console.error('\nğŸ’¥ Batch Ã©chouÃ© :', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Lancer si exÃ©cutÃ© directement
if (require.main === module) {
  main();
}