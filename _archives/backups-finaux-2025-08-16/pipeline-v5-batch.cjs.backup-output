// pipeline-v5-batch.cjs - Pipeline batch utilisant l'agent-veille-v5 en mode dirig√©
require('dotenv').config({ path: '../config/.env' });
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

// Configuration
const CONFIG = {
  AGENTS: {
    veille: './agent-veille-v5.cjs', // Nouvelle version
    redacteurFactuel: './agent-redacteur-factuel.cjs',
    styleConversationnel: './agent-style-conversationnel.cjs'
  },
  STRUCTURE: {
    base: './output',
    veille: '01-veille',
    corpus: '02-corpus',
    factuels: '03-articles-factuels',
    conversationnels: '04-articles-conversationnels',
    finaux: '05-articles-finaux',
    rapports: '06-rapports',
    archives: '07-archives'
  },
  VALIDATION: {
    longueurMin: 1400,
    longueurMax: 1800,
    longueurCible: 1500
  },
  BATCH: {
    pauseEntreSujets: 20000, // 20 secondes entre chaque article
    pauseCourtePourAPI: 5000, // 5 secondes pour √©viter rate limiting
    maxRetries: 2
  }
};

// LISTE DES SUJETS √Ä TRAITER
const SUJETS_BATCH = [
  // Actualit√©s (4 articles)
  {
    titre: "IA g√©n√©rative 2025 : les outils indispensables pour les PME fran√ßaises",
    category: "actualites",
    angle: "Pr√©sentation des nouveaux outils avec ROI prouv√© et cas d'usage concrets",
    keywords: "ChatGPT Enterprise, Claude, Microsoft Copilot, Mistral, productivit√©, PME, France"
  },
  {
    titre: "R√©glementation IA europ√©enne : guide de conformit√© pratique pour PME",
    category: "actualites",
    angle: "D√©cryptage de l'AI Act avec check-list de mise en conformit√©",
    keywords: "AI Act, RGPD, conformit√©, r√©glementation, √©thique IA, Europe, PME"
  },
  {
    titre: "Microsoft Copilot vs ChatGPT Enterprise : comparatif d√©taill√© pour PME",
    category: "actualites",
    angle: "Analyse comparative avec prix, fonctionnalit√©s et recommandations",
    keywords: "Copilot, ChatGPT, comparatif, assistant IA, productivit√©, entreprise"
  },
  {
    titre: "L'IA dans la comptabilit√© : automatisation et gains de productivit√© mesur√©s",
    category: "actualites",
    angle: "Solutions concr√®tes pour automatiser saisie, facturation et reporting",
    keywords: "comptabilit√©, automatisation, Pennylane, Dext, gains productivit√©, PME"
  },
  
  // Guides Pratiques (4 articles)
  {
    titre: "Impl√©menter ChatGPT dans votre service client : guide complet √©tape par √©tape",
    category: "guides",
    angle: "Tutoriel d√©taill√© avec param√©trage, formation √©quipes et mesure ROI",
    keywords: "service client, chatbot, ChatGPT, implementation, ROI, support"
  },
  {
    titre: "Automatiser sa prospection commerciale avec l'IA : m√©thode en 5 √©tapes",
    category: "guides",
    angle: "Process pour identifier, qualifier et contacter automatiquement les prospects",
    keywords: "prospection, commercial, automatisation, CRM, leads, Sales"
  },
  {
    titre: "Cr√©er du contenu marketing avec l'IA : workflow complet et outils test√©s",
    category: "guides",
    angle: "M√©thodologie pour g√©n√©rer articles, posts sociaux et newsletters",
    keywords: "content marketing, r√©daction, IA g√©n√©rative, workflow, cr√©ation contenu"
  },
  {
    titre: "Calculer le ROI de l'IA dans votre PME : m√©thode et exemples chiffr√©s",
    category: "guides",
    angle: "Framework de calcul avec cas pratiques et template Excel",
    keywords: "ROI, rentabilit√©, investissement, m√©triques, calcul, KPI"
  },
  
  // Analyses (2 articles)
  {
    titre: "Adoption de l'IA dans les PME fran√ßaises 2025 : chiffres et tendances",
    category: "analyses",
    angle: "√âtat des lieux chiffr√© avec freins, opportunit√©s et projections",
    keywords: "statistiques, adoption IA, PME, France, tendances, √©tude march√©"
  },
  {
    titre: "IA et cybers√©curit√© : nouveaux risques et solutions pour les PME",
    category: "analyses",
    angle: "Analyse des menaces et guide de protection des donn√©es",
    keywords: "cybers√©curit√©, risques IA, protection donn√©es, RGPD, s√©curit√©"
  }
];

class PipelineV5Batch {
  constructor() {
    this.sessionId = this.genererSessionId();
    this.resultats = {
      total: SUJETS_BATCH.length,
      reussis: 0,
      echecs: 0,
      articles: [],
      erreurs: []
    };
    this.startTime = Date.now();
  }

  genererSessionId() {
    const date = new Date();
    return `batch-v5-${date.toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '-')}`;
  }

  async initialiser() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          PIPELINE V5 BATCH - PRIZM AI                  ‚ïë
‚ïë      G√©n√©ration dirig√©e de ${String(SUJETS_BATCH.length).padEnd(2)} articles               ‚ïë
‚ïë                                                        ‚ïë
‚ïë  Session : ${this.sessionId}            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);

    // Cr√©er la structure
    await this.creerStructure();
    
    // V√©rifier les agents
    await this.verifierAgents();
    
    // Archiver les anciennes veilles pour √©viter les conflits
    await this.archiverAnciennesVeilles();
    
    console.log('\n‚úÖ Pipeline batch v5 initialis√©');
    console.log('üéØ Mode : DIRIG√â (sujets impos√©s)\n');
    console.log(`üìã Articles √† g√©n√©rer :`);
    SUJETS_BATCH.forEach((s, i) => {
      console.log(`   ${i + 1}. [${s.category}] ${s.titre}`);
    });
    console.log('\n' + '‚ïê'.repeat(60) + '\n');
    
    return true;
  }

  async creerStructure() {
    for (const [key, dossier] of Object.entries(CONFIG.STRUCTURE)) {
      if (key !== 'base') {
        const chemin = path.join(CONFIG.STRUCTURE.base, dossier);
        await fs.mkdir(chemin, { recursive: true });
      }
    }
  }

  async verifierAgents() {
    console.log('üîç V√©rification des agents...');
    for (const [nom, fichier] of Object.entries(CONFIG.AGENTS)) {
      try {
        await fs.access(fichier);
        console.log(`   ‚úì ${nom} (${fichier})`);
      } catch {
        throw new Error(`Agent ${nom} introuvable : ${fichier}`);
      }
    }
  }

  async archiverAnciennesVeilles() {
    try {
      const veilleDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.veille);
      const archiveDir = path.join(
        CONFIG.STRUCTURE.base, 
        CONFIG.STRUCTURE.archives, 
        'veilles-avant-batch-v5',
        this.sessionId
      );
      
      await fs.mkdir(archiveDir, { recursive: true });
      
      // Fonction r√©cursive pour archiver
      async function archiverRecursif(source, dest) {
        const entrees = await fs.readdir(source, { withFileTypes: true });
        
        for (const entree of entrees) {
          const sourcePath = path.join(source, entree.name);
          const destPath = path.join(dest, entree.name);
          
          if (entree.isDirectory()) {
            await fs.mkdir(destPath, { recursive: true });
            await archiverRecursif(sourcePath, destPath);
          } else if (entree.isFile() && entree.name.endsWith('.md')) {
            await fs.rename(sourcePath, destPath);
          }
        }
      }
      
      const files = await fs.readdir(veilleDir);
      if (files.length > 0) {
        await archiverRecursif(veilleDir, archiveDir);
        console.log(`   üì¶ Anciennes veilles archiv√©es dans : ${archiveDir}`);
      }
    } catch (e) {
      // Pas grave si le dossier est vide
    }
  }

  /**
   * G√©n√©rer un article pour un sujet impos√©
   */
  async genererArticlePourSujet(sujet, numero) {
    console.log(`\n${'‚îÄ'.repeat(60)}`);
    console.log(`[${numero}/${SUJETS_BATCH.length}] ${sujet.titre}`);
    console.log(`   üìÇ Cat√©gorie : ${sujet.category}`);
    console.log(`   üéØ Angle : ${sujet.angle.substring(0, 60)}...`);
    
    try {
      // √âtape 1 : Lancer l'agent-veille-v5 en mode DIRIG√â
      console.log(`\n   üì∞ Lancement de la veille dirig√©e...`);
      const debutVeille = Date.now();
      
      // Construire la commande avec tous les param√®tres
      const commande = [
        `node ${CONFIG.AGENTS.veille}`,
        '--dirige',
        `--titre "${sujet.titre}"`,
        `--angle "${sujet.angle}"`,
        `--keywords "${sujet.keywords}"`,
        `--category "${sujet.category}"`
      ].join(' ');
      
      try {
        const { stdout, stderr } = await execPromise(commande);
        
        if (stderr && !stderr.includes('Warning')) {
          console.log('   ‚ö†Ô∏è Avertissements :', stderr.substring(0, 100));
        }
        
        // Attendre que le corpus soit cr√©√©
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        console.log(`   ‚úÖ Veille et corpus cr√©√©s en ${Math.round((Date.now() - debutVeille) / 1000)}s`);
        
      } catch (error) {
        throw new Error(`Erreur veille dirig√©e : ${error.message}`);
      }
      
      // √âtape 2 : Trouver le corpus cr√©√©
      const corpusPath = await this.trouverDernierCorpus(sujet.titre);
      
      if (!corpusPath) {
        throw new Error('Corpus non trouv√© apr√®s la veille');
      }
      
      console.log(`   üìö Corpus trouv√© : ${path.basename(corpusPath)}`);
      
      // √âtape 3 : Lancer la r√©daction factuelle
      console.log(`   ‚úçÔ∏è G√©n√©ration de l'article factuel...`);
      const debutRedaction = Date.now();
      
      const commandeRedaction = `node ${CONFIG.AGENTS.redacteurFactuel} "${corpusPath}"`;
      
      try {
        await execPromise(commandeRedaction);
        console.log(`   ‚úÖ Article factuel g√©n√©r√© en ${Math.round((Date.now() - debutRedaction) / 1000)}s`);
      } catch (error) {
        throw new Error(`Erreur r√©daction : ${error.message}`);
      }
      
      // √âtape 4 : Appliquer le style conversationnel (optionnel)
      const articleFactuel = await this.trouverDernierArticleFactuel();
      
      if (articleFactuel) {
        console.log(`   üó£Ô∏è Application du style conversationnel...`);
        try {
          await execPromise(`node ${CONFIG.AGENTS.styleConversationnel} "${articleFactuel}"`);
          console.log(`   ‚úÖ Style conversationnel appliqu√©`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è Style conversationnel √©chou√© (non bloquant)`);
        }
      }
      
      // √âtape 5 : R√©cup√©rer et formater l'article final
      const articleFinal = await this.recupererEtFormaterArticle(sujet, numero);
      
      if (articleFinal) {
        this.resultats.articles.push({
          sujet: sujet.titre,
          category: sujet.category,
          fichier: articleFinal.fichier,
          chemin: articleFinal.chemin,
          duree: Math.round((Date.now() - debutVeille) / 1000)
        });
        this.resultats.reussis++;
        
        console.log(`   ‚úÖ Article compl√©t√© en ${Math.round((Date.now() - debutVeille) / 1000)}s total`);
      }
      
      return true;
      
    } catch (error) {
      console.log(`   ‚ùå √âchec : ${error.message}`);
      this.resultats.echecs++;
      this.resultats.erreurs.push({
        sujet: sujet.titre,
        erreur: error.message
      });
      return false;
    }
  }

  /**
   * Trouver le corpus cr√©√© pour un sujet
   */
  async trouverDernierCorpus(titreSujet) {
    const date = new Date().toISOString().split('T')[0];
    const corpusDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.corpus, date);
    
    try {
      const dossiers = await fs.readdir(corpusDir);
      
      // Cr√©er un slug du titre pour la recherche
      const titreSanitize = titreSujet.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .substring(0, 50);
      
      // Chercher un dossier qui correspond
      const dossierTrouve = dossiers.find(d => {
        const dLower = d.toLowerCase();
        // Chercher par mots cl√©s du titre
        const motsCles = titreSanitize.split('-').filter(m => m.length > 3);
        return motsCles.some(mot => dLower.includes(mot));
      });
      
      if (dossierTrouve) {
        return path.join(corpusDir, dossierTrouve);
      }
      
      // Si pas trouv√©, prendre le plus r√©cent
      if (dossiers.length > 0) {
        const dernierDossier = dossiers.sort().pop();
        return path.join(corpusDir, dernierDossier);
      }
      
    } catch (error) {
      console.log('   ‚ö†Ô∏è Erreur recherche corpus :', error.message);
    }
    
    return null;
  }

  /**
   * Trouver le dernier article factuel g√©n√©r√©
   */
  async trouverDernierArticleFactuel() {
    const factuelDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.factuels);
    
    try {
      const fichiers = await fs.readdir(factuelDir);
      const articles = fichiers.filter(f => f.endsWith('.md'));
      
      if (articles.length > 0) {
        const dernier = articles.sort().pop();
        return path.join(factuelDir, dernier);
      }
    } catch (error) {
      console.log('   ‚ö†Ô∏è Article factuel non trouv√©');
    }
    
    return null;
  }

  /**
   * R√©cup√©rer et formater l'article final
   */
  async recupererEtFormaterArticle(sujet, numero) {
    try {
      // Chercher dans les articles finaux
      const finauxDir = path.join(CONFIG.STRUCTURE.base, CONFIG.STRUCTURE.finaux);
      const fichiers = await fs.readdir(finauxDir);
      
      const articles = fichiers.filter(f => f.endsWith('.md'));
      if (articles.length === 0) return null;
      
      // Prendre le plus r√©cent
      const dernierArticle = articles.sort().pop();
      const cheminArticle = path.join(finauxDir, dernierArticle);
      
      // Lire le contenu
      let contenu = await fs.readFile(cheminArticle, 'utf-8');
      
      // Corriger l'encodage
      contenu = this.corrigerEncodage(contenu);
      
      // Ajouter/corriger le frontmatter
      contenu = this.ajouterFrontmatter(contenu, sujet);
      
      // Cr√©er le nom final
      const date = new Date().toISOString().split('T')[0];
      const slug = sujet.titre.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .substring(0, 60);
      
      const nomFinal = `${date}-${String(numero).padStart(2, '0')}-${slug}.md`;
      
      // Sauvegarder dans le dossier de staging
      const stagingDir = path.join(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready');
      await fs.mkdir(stagingDir, { recursive: true });
      
      const cheminFinal = path.join(stagingDir, nomFinal);
      await fs.writeFile(cheminFinal, contenu, 'utf-8');
      
      console.log(`   üìÑ Article format√© : ${nomFinal}`);
      
      return {
        fichier: nomFinal,
        chemin: cheminFinal
      };
      
    } catch (error) {
      console.log('   ‚ö†Ô∏è Erreur formatage article :', error.message);
      return null;
    }
  }

  corrigerEncodage(texte) {
    const replacements = {
      '√©': '√©', '√®': '√®', '√†': '√†', '√¢': '√¢', '√™': '√™',
      '√¥': '√¥', '√π': '√π', '√ª': '√ª', '√ß': '√ß', '√Æ': '√Æ',
      '√Ø': '√Ø', '√Ö"': '≈ì', '√â': '√â', '√à': '√à', '√Ä': '√Ä',
      '√¢‚Ç¨‚Ñ¢': "'", '√¢‚Ç¨≈ì': '"', '√¢‚Ç¨': '"', '√¢‚Ç¨¬¶': '...',
      '√¢‚Ç¨"': '‚Äî', '√¢‚Ç¨"': '‚Äì', '√¢‚Äû¬¢': '‚Ñ¢', '√Ç¬©': '¬©'
    };
    
    let fixed = texte;
    for (const [bad, good] of Object.entries(replacements)) {
      fixed = fixed.replace(new RegExp(bad, 'g'), good);
    }
    return fixed;
  }

  ajouterFrontmatter(contenu, sujet) {
    // Supprimer l'ancien frontmatter s'il existe
    contenu = contenu.replace(/^---[\s\S]*?---\n*/m, '');
    
    // Extraire le titre du contenu
    const titleMatch = contenu.match(/^#\s+(.+)$/m);
    const title = titleMatch ? titleMatch[1] : sujet.titre;
    
    // Calculer le temps de lecture
    const wordCount = contenu.split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 250);
    
    // G√©n√©rer la description
    const description = sujet.angle.substring(0, 150) + '...';
    
    // D√©terminer l'emoji selon la cat√©gorie
    const emojis = {
      'actualites': 'üöÄ',
      'guides': 'üìö',
      'analyses': 'üìä'
    };
    
    const date = new Date().toISOString().split('T')[0];
    
    // Cr√©er le frontmatter
    const frontmatter = `---
title: "${title}"
description: "${description}"
pubDate: ${date}
author: "L'√©quipe Prizm AI"
emoji: "${emojis[sujet.category] || 'üí°'}"
category: "${sujet.category}"
featured: ${this.resultats.reussis < 3 ? 'true' : 'false'}
readingTime: "${readingTime} min"
---

`;
    
    return frontmatter + contenu;
  }

  /**
   * Ex√©cuter le batch complet
   */
  async executer() {
    try {
      await this.initialiser();
      
      // Traiter chaque sujet
      for (let i = 0; i < SUJETS_BATCH.length; i++) {
        const sujet = SUJETS_BATCH[i];
        const numero = i + 1;
        
        // G√©n√©rer l'article
        await this.genererArticlePourSujet(sujet, numero);
        
        // Pause entre les articles (sauf pour le dernier)
        if (i < SUJETS_BATCH.length - 1) {
          const pauseSeconds = CONFIG.BATCH.pauseEntreSujets / 1000;
          console.log(`\n   ‚è∏Ô∏è Pause de ${pauseSeconds}s avant le prochain article...`);
          await new Promise(resolve => setTimeout(resolve, CONFIG.BATCH.pauseEntreSujets));
        }
      }
      
      // Rapport final
      await this.genererRapport();
      
      return this.resultats;
      
    } catch (error) {
      console.error('\n‚ùå ERREUR PIPELINE BATCH :', error.message);
      throw error;
    }
  }

  /**
   * G√©n√©rer le rapport final et le script de publication
   */
  async genererRapport() {
    const dureeTotal = Math.round((Date.now() - this.startTime) / 1000 / 60);
    
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              BATCH V5 TERMIN√â                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä R√âSUM√â DE LA SESSION ${this.sessionId}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚è±Ô∏è Dur√©e totale : ${dureeTotal} minutes
‚úÖ Articles r√©ussis : ${this.resultats.reussis}/${this.resultats.total}
‚ùå √âchecs : ${this.resultats.echecs}
`);

    if (this.resultats.reussis > 0) {
      console.log('\nüìÑ ARTICLES G√âN√âR√âS :');
      
      // Grouper par cat√©gorie
      const parCategorie = {};
      this.resultats.articles.forEach(article => {
        if (!parCategorie[article.category]) {
          parCategorie[article.category] = [];
        }
        parCategorie[article.category].push(article);
      });
      
      for (const [category, articles] of Object.entries(parCategorie)) {
        console.log(`\n   ${category.toUpperCase()} (${articles.length}) :`);
        articles.forEach((article, i) => {
          console.log(`   ${i + 1}. ${article.sujet}`);
          console.log(`      üìÅ ${article.fichier}`);
          console.log(`      ‚è±Ô∏è ${article.duree}s`);
        });
      }
    }

    if (this.resultats.echecs > 0) {
      console.log('\n‚ö†Ô∏è ERREURS RENCONTR√âES :');
      this.resultats.erreurs.forEach(err => {
        console.log(`   - ${err.sujet}`);
        console.log(`     ${err.erreur}`);
      });
    }

    // Sauvegarder le rapport JSON
    const rapportPath = path.join(
      CONFIG.STRUCTURE.base,
      CONFIG.STRUCTURE.rapports,
      `rapport-${this.sessionId}.json`
    );
    
    await fs.writeFile(
      rapportPath,
      JSON.stringify(this.resultats, null, 2),
      'utf-8'
    );
    
    // Cr√©er un script PowerShell pour publier
    const scriptPublish = `
# Script de publication des articles g√©n√©r√©s - Pipeline V5
# Session : ${this.sessionId}
# Date : ${new Date().toLocaleString('fr-FR')}

$source = "${path.resolve(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready')}"
$dest = "C:\\Users\\Samuel\\Documents\\prizmia\\src\\content\\blog"

Write-Host ""
Write-Host "üìö PUBLICATION DES ARTICLES BATCH V5" -ForegroundColor Cyan
Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor Cyan
Write-Host ""
Write-Host "Source : $source" -ForegroundColor Gray
Write-Host "Destination : $dest" -ForegroundColor Gray
Write-Host ""

$files = Get-ChildItem -Path $source -Filter "*.md"
$count = $files.Count

Write-Host "üìä $count articles √† copier" -ForegroundColor Yellow
Write-Host ""

$copied = 0
foreach ($file in $files) {
    try {
        Copy-Item $file.FullName -Destination $dest -Force
        $copied++
        Write-Host "  ‚úÖ $($file.Name)" -ForegroundColor Green
    } catch {
        Write-Host "  ‚ùå Erreur avec $($file.Name): $_" -ForegroundColor Red
    }
}

Write-Host ""
Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor Cyan
Write-Host "‚ú® Termin√© ! $copied/$count articles copi√©s." -ForegroundColor Green
Write-Host ""
Write-Host "Prochaines √©tapes :" -ForegroundColor Yellow
Write-Host "  1. cd C:\\Users\\Samuel\\Documents\\prizmia" -ForegroundColor White
Write-Host "  2. npm run dev  # Pour tester localement" -ForegroundColor White
Write-Host "  3. git add ." -ForegroundColor White
Write-Host "  4. git commit -m 'Ajout de $copied articles - Batch V5'" -ForegroundColor White
Write-Host "  5. git push" -ForegroundColor White
Write-Host ""
`;

    const scriptPath = path.join(CONFIG.STRUCTURE.base, 'articles-batch-v5-ready', 'publish-to-blog.ps1');
    await fs.writeFile(scriptPath, scriptPublish, 'utf-8');
    
    console.log(`
üìã PROCHAINES √âTAPES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. V√©rifier les articles :
   cd output/articles-batch-v5-ready
   dir *.md
   
2. Publier avec PowerShell :
   .\\publish-to-blog.ps1
   
3. Tester localement :
   cd C:\\Users\\Samuel\\Documents\\prizmia
   npm run dev
   # Ouvrir http://localhost:4321
   
4. D√©ployer :
   git add .
   git commit -m "Ajout de ${this.resultats.reussis} articles - Pipeline V5 Batch"
   git push

üíæ Rapport sauvegard√© : ${rapportPath}
üìú Script de publication : publish-to-blog.ps1

‚ú® Pipeline V5 Batch termin√© avec succ√®s !
`);
  }
}

// === POINT D'ENTR√âE ===
async function main() {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
üöÄ Pipeline V5 Batch - Prizm AI
================================

G√©n√®re des articles en mode DIRIG√â avec trois options possibles.

Usage :
  node pipeline-v5-batch.cjs [options]              # Sujets pr√©d√©finis
  node pipeline-v5-batch.cjs --single [params]      # Un seul sujet
  node pipeline-v5-batch.cjs --file <fichier.json>  # Liste depuis fichier

Options g√©n√©rales :
  --test       Mode test (g√©n√®re seulement 2 articles)
  --rapide     Pauses r√©duites (10s au lieu de 20s)
  --help, -h   Affiche cette aide

Mode SINGLE (un seul sujet) :
  --single     Active le mode sujet unique
  --titre      Titre du sujet (obligatoire)
  --category   actualites|guides|analyses (d√©faut: actualites)
  --angle      Angle √©ditorial (optionnel)
  --keywords   Mots-cl√©s s√©par√©s par virgules (optionnel)

Mode FILE (liste depuis fichier) :
  --file       Chemin vers un fichier JSON contenant les sujets

Exemples :
  # Utiliser les 10 sujets pr√©d√©finis
  node pipeline-v5-batch.cjs
  
  # G√©n√©rer un seul article sur un sujet sp√©cifique
  node pipeline-v5-batch.cjs --single \\
    --titre "L'IA dans le e-commerce en 2025" \\
    --category "guides" \\
    --angle "Solutions pratiques pour boutiques en ligne"
  
  # Utiliser une liste personnalis√©e
  node pipeline-v5-batch.cjs --file mes-sujets.json
  
  # Mode test avec sujets pr√©d√©finis
  node pipeline-v5-batch.cjs --test

Format du fichier JSON :
[
  {
    "titre": "Titre du sujet",
    "category": "actualites",
    "angle": "Angle √©ditorial",
    "keywords": "mot1, mot2, mot3"
  },
  ...
]

Dur√©e estim√©e : 
  - Un sujet : ~2-3 minutes
  - 10 sujets : ~30-40 minutes
    `);
    process.exit(0);
  }
  
  const pipeline = new PipelineV5Batch();
  
  try {
    let sujetsATraiter = SUJETS_BATCH;
    
    // Mode SINGLE : un seul sujet depuis la ligne de commande
    if (args.includes('--single')) {
      const titreIndex = args.findIndex(a => a === '--titre');
      if (titreIndex === -1 || !args[titreIndex + 1]) {
        console.error('‚ùå Le mode --single n√©cessite un --titre');
        process.exit(1);
      }
      
      const sujetUnique = {
        titre: args[titreIndex + 1],
        category: 'actualites',
        angle: 'Analyse pratique pour PME/ETI',
        keywords: 'PME, ETI, France, transformation digitale'
      };
      
      // Param√®tres optionnels
      const categoryIndex = args.findIndex(a => a === '--category');
      if (categoryIndex !== -1 && args[categoryIndex + 1]) {
        sujetUnique.category = args[categoryIndex + 1];
      }
      
      const angleIndex = args.findIndex(a => a === '--angle');
      if (angleIndex !== -1 && args[angleIndex + 1]) {
        sujetUnique.angle = args[angleIndex + 1];
      }
      
      const keywordsIndex = args.findIndex(a => a === '--keywords');
      if (keywordsIndex !== -1 && args[keywordsIndex + 1]) {
        sujetUnique.keywords = args[keywordsIndex + 1];
      }
      
      sujetsATraiter = [sujetUnique];
      console.log('\nüìù MODE SINGLE : Un seul article');
      console.log(`   Sujet : ${sujetUnique.titre}`);
      console.log(`   Cat√©gorie : ${sujetUnique.category}\n`);
    }
    
    // Mode FILE : charger depuis un fichier JSON
    else if (args.includes('--file')) {
      const fileIndex = args.findIndex(a => a === '--file');
      if (fileIndex === -1 || !args[fileIndex + 1]) {
        console.error('‚ùå Le mode --file n√©cessite un nom de fichier');
        process.exit(1);
      }
      
      const filepath = args[fileIndex + 1];
      try {
        const fileContent = await fs.readFile(filepath, 'utf-8');
        sujetsATraiter = JSON.parse(fileContent);
        
        // Validation basique
        if (!Array.isArray(sujetsATraiter) || sujetsATraiter.length === 0) {
          throw new Error('Le fichier doit contenir un tableau de sujets');
        }
        
        // V√©rifier que chaque sujet a au moins un titre
        sujetsATraiter.forEach((s, i) => {
          if (!s.titre) {
            throw new Error(`Le sujet ${i + 1} n'a pas de titre`);
          }
          // Ajouter les valeurs par d√©faut si manquantes
          s.category = s.category || 'actualites';
          s.angle = s.angle || 'Analyse pratique pour PME/ETI';
          s.keywords = s.keywords || 'PME, ETI, France';
        });
        
        console.log(`\nüìÑ MODE FILE : ${sujetsATraiter.length} sujets charg√©s depuis ${filepath}\n`);
        
      } catch (error) {
        console.error(`‚ùå Erreur lecture fichier : ${error.message}`);
        process.exit(1);
      }
    }
    
    // Mode test : limiter le nombre de sujets
    if (args.includes('--test')) {
      const nbTest = Math.min(2, sujetsATraiter.length);
      sujetsATraiter = sujetsATraiter.slice(0, nbTest);
      console.log(`\n‚ö†Ô∏è MODE TEST : ${nbTest} articles seulement\n`);
    }
    
    // Mode rapide : pauses r√©duites
    if (args.includes('--rapide')) {
      CONFIG.BATCH.pauseEntreSujets = 10000;
      console.log('\n‚ö° MODE RAPIDE : Pauses r√©duites\n');
    }
    
    // Remplacer SUJETS_BATCH par les sujets √† traiter
    SUJETS_BATCH.length = 0;
    SUJETS_BATCH.push(...sujetsATraiter);
    
    console.time('‚è±Ô∏è Dur√©e totale du batch');
    await pipeline.executer();
    console.timeEnd('‚è±Ô∏è Dur√©e totale du batch');
    
    process.exit(0);
    
  } catch (error) {
    console.error('\nüí• Batch √©chou√© :', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Lancer si ex√©cut√© directement
if (require.main === module) {
  main();
}